diff -Nru teeworlds-0.5.2-src/datasrc/content.py teeworlds-0.5.2-teecomp/datasrc/content.py
--- teeworlds-0.5.2-src/datasrc/content.py	2009-10-26 19:04:31.000000000 +0100
+++ teeworlds-0.5.2-teecomp/datasrc/content.py	2009-10-27 19:06:18.000000000 +0100
@@ -228,6 +228,7 @@
 
 container.images.Add(image_null)
 container.images.Add(image_game)
+container.images.Add(Image("game_gray", "game.png"))
 container.images.Add(image_particles)
 container.images.Add(Image("cursor", "gui_cursor.png"))
 container.images.Add(Image("banner", "gui_logo.png"))
diff -Nru teeworlds-0.5.2-src/readme_teecomp.txt teeworlds-0.5.2-teecomp/readme_teecomp.txt
--- teeworlds-0.5.2-src/readme_teecomp.txt	1970-01-01 01:00:00.000000000 +0100
+++ teeworlds-0.5.2-teecomp/readme_teecomp.txt	2009-11-10 17:00:09.000000000 +0100
@@ -0,0 +1,96 @@
+
+         _____         ___                
+        |_   _|__ ___ / __|___ _ __  _ __ 
+          | |/ -_) -_) (__/ _ \ '  \| '_ \
+          |_|\___\___|\___\___/_|_|_| .__/
+                                    |_|   
+
+
+TeeComp is a modification of the standard Teeworlds client (client mod).
+It includes several features players from Unreal Tournament or Quake like.
+The binary file is guaranteed without aimbot, cheating system, virus, keylogger or any other malware that could
+damage your system or send personal data over the Internet.
+
+==========
+ Features
+==========
+* Custom Tees' colors in team games
+* HUD colors matching Tees' ones
+* Flags colors matching Tees' ones
+* Force opponents' skin
+* Use DM colors in team games
+* Custom name plates colors by team
+* Shadow under the name plates for an improved readability
+* Score displayed in name plates
+* Custom laser color
+* Stat board with
+  * Frags, deaths, and suicides count
+  * Ratio or net score
+  * Frags per minute
+  * Frags and deaths for each weapon
+  * Captured flags count
+* Displaying of Tee's speed
+* Disabling chat
+* Player following while spectating
+* Automatic demo recording
+* Automatic screenshot at the end of the match
+
+All these features are also available when watching a demo recorded from a standard client.
+TeeComp is compatible with any game mode accepting standard clients.
+
+===========
+ Downloads
+===========
+
+TeeComp is available for Windows (XP or better) and Linux.
+Visit http://spl0k.unreal-design.com/teeworlds/downloads/
+Check http://eigan.no/tee/ for Mac versions.
+
+=======
+ Usage
+=======
+
+After downloading the file, unzip (untar) it in your Teeworlds folder and run teecomp.exe (teecomp) instead
+of teeworlds.exe (teeworlds).
+
+=========
+ Credits
+=========
+
+TeeComp, by Alban 'spl0k' Feron
+ - http://spl0k.unreal-design.com/
+but two or three lines are from torch ;)
+
+Based on the standard Teeworlds client, mainly by Magnus 'matricks' Auvinen
+ - http://www.teeworlds.com/
+
+With some advices from Sd`, Tho, Eve and some other MonkeyStyle members
+
+===========
+ Changelog
+===========
+
+Version 0.7.0
+- Fixed connection crash when one wished to display scores
+- Added warmup end support with stats
+- Added ability to choose which fields are displayed on the global stat board
+- Added fields to the global stat board:
+  - Suicides
+  - Captured flags
+- Added an individual stat board
+- Added ability to hide the flag when we're carrying it
+- Added ability to force other players' skins
+- Added option to use DM colors in team games
+- Added option to change laser color
+- Added ability to mute chat
+- Added player following in spectator mode
+
+Version 0.6.4
+- Fixed auto screenshot applying to demos
+- Chat now use Tees colors
+- Added a 'Reset to defaults' button to the settings page
+- Team names now match Tees colors in the score board and in-game menu.
+
+Version 0.6.0
+- First release
+
diff -Nru teeworlds-0.5.2-src/src/engine/client/ec_client.c teeworlds-0.5.2-teecomp/src/engine/client/ec_client.c
--- teeworlds-0.5.2-src/src/engine/client/ec_client.c	2009-10-26 19:04:31.000000000 +0100
+++ teeworlds-0.5.2-teecomp/src/engine/client/ec_client.c	2009-10-27 19:06:18.000000000 +0100
@@ -5,6 +5,7 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include <math.h>
+#include <time.h>
 
 #include <base/system.h>
 #include <engine/e_engine.h>
@@ -578,6 +579,19 @@
 		modc_statechange(state, old);
 }
 
+void teecomp_demo_start()
+{
+	char filename[512];
+	time_t rawtime;
+	struct tm *tmp;
+
+	time(&rawtime);
+	tmp = localtime(&rawtime);
+
+	str_format(filename, sizeof(filename), "demos/%d-%02d-%d_%02d-%02d-%02d_%s.demo", tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday, tmp->tm_hour, tmp->tm_min, tmp->tm_sec, current_map);
+	demorec_record_start(filename, modc_net_version(), current_map, current_map_crc, "client");
+}
+
 /* called when the map is loaded and we should init for a new round */
 static void client_on_enter_game()
 {
diff -Nru teeworlds-0.5.2-src/src/engine/e_if_client.h teeworlds-0.5.2-teecomp/src/engine/e_if_client.h
--- teeworlds-0.5.2-src/src/engine/e_if_client.h	2009-10-26 19:04:31.000000000 +0100
+++ teeworlds-0.5.2-teecomp/src/engine/e_if_client.h	2009-10-27 19:06:18.000000000 +0100
@@ -576,4 +576,7 @@
 void client_serverinfo(SERVER_INFO *serverinfo);
 void client_serverinfo_request();
 void client_serverbrowse_request(NETADDR *addr);
+
+void teecomp_demo_start();
+
 #endif
diff -Nru teeworlds-0.5.2-src/src/game/client/components/camera.cpp teeworlds-0.5.2-teecomp/src/game/client/components/camera.cpp
--- teeworlds-0.5.2-src/src/game/client/components/camera.cpp	2009-10-26 19:04:31.000000000 +0100
+++ teeworlds-0.5.2-teecomp/src/game/client/components/camera.cpp	2009-10-27 19:06:18.000000000 +0100
@@ -22,7 +22,12 @@
 
 	// update camera center		
 	if(gameclient.snap.spectate)
-		center = gameclient.controls->mouse_pos;
+	{
+		if(gameclient.freeview)
+			center = gameclient.controls->mouse_pos;
+		else
+			center = gameclient.spectate_pos;
+	}
 	else
 	{
 
diff -Nru teeworlds-0.5.2-src/src/game/client/components/chat.cpp teeworlds-0.5.2-teecomp/src/game/client/components/chat.cpp
--- teeworlds-0.5.2-src/src/game/client/components/chat.cpp	2009-10-26 19:04:31.000000000 +0100
+++ teeworlds-0.5.2-teecomp/src/game/client/components/chat.cpp	2009-10-27 19:06:18.000000000 +0100
@@ -5,6 +5,7 @@
 #include <game/generated/gc_data.hpp>
 
 #include <game/client/gameclient.hpp>
+#include <game/client/teecomp.hpp>
 
 #include <game/client/components/sounds.hpp>
 
@@ -88,11 +89,12 @@
 	if(msgtype == NETMSGTYPE_SV_CHAT)
 	{
 		NETMSG_SV_CHAT *msg = (NETMSG_SV_CHAT *)rawmsg;
-		add_line(msg->cid, msg->team, msg->message);
+		if(msg->cid < 0 || !config.tc_disable_chat)
+			add_line(msg->cid, msg->team, msg->message);
 
-		if(msg->cid >= 0)
+		if(msg->cid >= 0 && !config.tc_disable_chat)
 			gameclient.sounds->play(SOUNDS::CHN_GUI, SOUND_CHAT_CLIENT, 0, vec2(0,0));
-		else
+		else if(msg->cid < 0)
 			gameclient.sounds->play(SOUNDS::CHN_GUI, SOUND_CHAT_SERVER, 0, vec2(0,0));
 	}
 }
@@ -184,15 +186,34 @@
 		cursor.line_width = 200.0f;
 
 		// render name
+		vec3 tcolor;
 		gfx_text_color(0.8f,0.8f,0.8f,1);
 		if(lines[r].client_id == -1)
 			gfx_text_color(1,1,0.5f,1); // system
 		else if(lines[r].team)
 			gfx_text_color(0.45f,0.9f,0.45f,1); // team message
 		else if(lines[r].name_color == 0)
-			gfx_text_color(1.0f,0.5f,0.5f,1); // red
+		{
+			if(!gameclient.snap.local_info)
+				gfx_text_color(1.0f,0.5f,0.5f,1); // red
+			else
+			{
+				tcolor = TeecompUtils::getTeamColor(0, gameclient.snap.local_info->team, config.tc_colored_tees_team1,
+						config.tc_colored_tees_team2, config.tc_colored_tees_method);
+				gfx_text_color(tcolor.r, tcolor.g, tcolor.b, 1);
+			}
+		}
 		else if(lines[r].name_color == 1)
-			gfx_text_color(0.7f,0.7f,1.0f,1); // blue
+		{
+			if(!gameclient.snap.local_info)
+				gfx_text_color(0.7f,0.7f,1.0f,1); // blue
+			else
+			{
+				tcolor = TeecompUtils::getTeamColor(1, gameclient.snap.local_info->team, config.tc_colored_tees_team1,
+						config.tc_colored_tees_team2, config.tc_colored_tees_method);
+				gfx_text_color(tcolor.r, tcolor.g, tcolor.b, 1);
+			}	
+		}
 		else if(lines[r].name_color == -1)
 			gfx_text_color(0.75f,0.5f,0.75f, 1); // spectator
 			
diff -Nru teeworlds-0.5.2-src/src/game/client/components/controls.cpp teeworlds-0.5.2-teecomp/src/game/client/components/controls.cpp
--- teeworlds-0.5.2-src/src/game/client/components/controls.cpp	2009-10-26 19:04:31.000000000 +0100
+++ teeworlds-0.5.2-teecomp/src/game/client/components/controls.cpp	2009-10-27 19:06:18.000000000 +0100
@@ -103,7 +103,15 @@
 		
 		input_direction_left = 0;
 		input_direction_right = 0;
-			
+
+		// Keep following while chatting/in console/in menu
+		if(gameclient.snap.spectate && !gameclient.freeview)
+		{
+			input_data.target_x = (int)mouse_pos.x;
+			input_data.target_y = (int)mouse_pos.y;
+			send = true;
+		}
+
 		mem_copy(data, &input_data, sizeof(input_data));
 
 		// send once a second just to be sure
@@ -189,11 +197,16 @@
 
 	if(gameclient.snap.spectate)
 	{
-		if(mouse_pos.x < 200.0f) mouse_pos.x = 200.0f;
-		if(mouse_pos.y < 200.0f) mouse_pos.y = 200.0f;
-		if(mouse_pos.x > col_width()*32-200.0f) mouse_pos.x = col_width()*32-200.0f;
-		if(mouse_pos.y > col_height()*32-200.0f) mouse_pos.y = col_height()*32-200.0f;
-		
+		if(gameclient.freeview)
+		{
+			if(mouse_pos.x < 200.0f) mouse_pos.x = 200.0f;
+			if(mouse_pos.y < 200.0f) mouse_pos.y = 200.0f;
+			if(mouse_pos.x > col_width()*32-200.0f) mouse_pos.x = col_width()*32-200.0f;
+			if(mouse_pos.y > col_height()*32-200.0f) mouse_pos.y = col_height()*32-200.0f;
+			
+		}
+		else
+			mouse_pos = gameclient.spectate_pos;
 		target_pos = mouse_pos;
 	}
 	else
diff -Nru teeworlds-0.5.2-src/src/game/client/components/hud.cpp teeworlds-0.5.2-teecomp/src/game/client/components/hud.cpp
--- teeworlds-0.5.2-src/src/game/client/components/hud.cpp	2009-10-26 19:04:31.000000000 +0100
+++ teeworlds-0.5.2-teecomp/src/game/client/components/hud.cpp	2009-10-27 19:06:18.000000000 +0100
@@ -1,6 +1,7 @@
 #include <memory.h> // memcmp
 
 #include <engine/e_client_interface.h>
+#include <engine/e_demorec.h>
 #include <game/generated/g_protocol.hpp>
 #include <game/generated/gc_data.hpp>
 
@@ -16,6 +17,8 @@
 #include "voting.hpp"
 #include "binds.hpp"
 
+#include <game/client/teecomp.hpp>
+
 HUD::HUD()
 {
 	
@@ -74,10 +77,20 @@
 			gfx_blend_normal();
 			gfx_texture_set(-1);
 			gfx_quads_begin();
-			if(t == 0)
-				gfx_setcolor(1,0,0,0.25f);
+			if(!config.tc_hud_match)
+			{
+				if(t == 0)
+					gfx_setcolor(1,0,0,0.25f);
+				else
+					gfx_setcolor(0,0,1,0.25f);
+			}
 			else
-				gfx_setcolor(0,0,1,0.25f);
+			{
+				vec3 col = TeecompUtils::getTeamColor(t, gameclient.snap.local_info->team,
+					config.tc_colored_tees_team1, config.tc_colored_tees_team2, config.tc_colored_tees_method);
+				gfx_setcolor(col.r, col.g, col.b, 0.25f);
+			}
+
 			draw_round_rect(whole-40, 300-40-15+t*20, 50, 18, 5.0f);
 			gfx_quads_end();
 
@@ -93,12 +106,25 @@
 					if(gameclient.snap.flags[t]->carried_by == -2 || (gameclient.snap.flags[t]->carried_by == -1 && ((client_tick()/10)&1)))
 					{
 						gfx_blend_normal();
-						gfx_texture_set(data->images[IMAGE_GAME].id);
+						if(config.tc_colored_flags)
+							gfx_texture_set(data->images[IMAGE_GAME_GRAY].id);
+						else
+							gfx_texture_set(data->images[IMAGE_GAME].id);
 						gfx_quads_begin();
 
 						if(t == 0) select_sprite(SPRITE_FLAG_RED);
 						else select_sprite(SPRITE_FLAG_BLUE);
 						
+						if(config.tc_colored_flags)
+						{
+							vec3 col = TeecompUtils::getTeamColor(t,
+								gameclient.snap.local_info->team,
+								config.tc_colored_tees_team1,
+								config.tc_colored_tees_team2,
+								config.tc_colored_tees_method);
+							gfx_setcolor(col.r, col.g, col.b, 1.0f);
+						}
+
 						float size = 16;					
 						gfx_quads_drawTL(whole-40+5, 300-40-15+t*20+1, size/2, size);
 						gfx_quads_end();
@@ -283,6 +309,66 @@
 	gfx_quads_end();
 }
 
+void HUD::render_speed()
+{
+	if(!config.tc_speedmeter)
+		return;
+
+	// We calculate the speed instead of getting it from character.velocity cause it's buggy when
+	// walking in front of a wall or when using the ninja sword
+	static float speed;
+	static vec2 oldpos;
+	static const int SMOOTH_TABLE_SIZE = 16;
+	static const int ACCEL_THRESHOLD = 25;
+	static float smooth_table[SMOOTH_TABLE_SIZE];
+	static int smooth_index = 0;
+
+	smooth_table[smooth_index] = distance(gameclient.local_character_pos, oldpos)/client_frametime();
+	if(demorec_isplaying()) {
+		float mult = client_demoplayer_getinfo()->speed;
+		smooth_table[smooth_index] /= mult;
+	}
+	smooth_index = (smooth_index + 1) % SMOOTH_TABLE_SIZE;
+	oldpos = gameclient.local_character_pos;
+	speed = 0;
+	for(int i=0; i<SMOOTH_TABLE_SIZE; i++)
+		speed += smooth_table[i];
+	speed /= SMOOTH_TABLE_SIZE;
+
+	int t = (gameclient.snap.gameobj->flags & GAMEFLAG_TEAMS)? -1 : 1;
+	int last_index = smooth_index - 1;
+	if(last_index < 0)
+		last_index = SMOOTH_TABLE_SIZE - 1;
+
+	gfx_blend_normal();
+	gfx_texture_set(-1);
+	gfx_quads_begin();
+	if(config.tc_speedmeter_accel && speed - smooth_table[last_index] > ACCEL_THRESHOLD)
+		gfx_setcolor(0.6f, 0.1f, 0.1f, 0.25f);
+	else if(config.tc_speedmeter_accel && speed - smooth_table[last_index] < -ACCEL_THRESHOLD)
+		gfx_setcolor(0.1f, 0.6f, 0.1f, 0.25f);
+	else
+		gfx_setcolor(0.1, 0.1, 0.1, 0.25);
+	draw_round_rect(width-40, 245+t*20, 50, 18, 5.0f);
+	gfx_quads_end();
+
+	char buf[16];
+	str_format(buf, sizeof(buf), "%.0f", speed);
+	gfx_text(0, width-5-gfx_text_width(0,12,buf,-1), 246+t*20, 12, buf, -1);
+}
+
+void HUD::render_spectate()
+{
+	if(gameclient.freeview)
+		gfx_text(0, 4*gfx_screenaspect(), 4, 8, "Freeview", -1);
+	else
+	{
+		char buf[96];
+		str_format(buf, sizeof(buf), "Following: %s", gameclient.clients[gameclient.spectate_cid].name);
+		gfx_text(0, 4*gfx_screenaspect(), 4, 8, buf, -1);
+	}
+}
+
 void HUD::on_render()
 {
 	if(!gameclient.snap.gameobj)
@@ -295,7 +381,10 @@
 		spectate = true;
 	
 	if(gameclient.snap.local_character && !spectate && !(gameclient.snap.gameobj && gameclient.snap.gameobj->game_over))
+	{
 		render_healthandammo();
+		render_speed();
+	}
 
 	render_goals();
 	render_fps();
@@ -304,4 +393,6 @@
 	render_teambalancewarning();
 	render_voting();
 	render_cursor();
+	if(spectate && !(gameclient.snap.gameobj && gameclient.snap.gameobj->game_over))
+		render_spectate();
 }
diff -Nru teeworlds-0.5.2-src/src/game/client/components/hud.hpp teeworlds-0.5.2-teecomp/src/game/client/components/hud.hpp
--- teeworlds-0.5.2-src/src/game/client/components/hud.hpp	2009-10-26 19:04:31.000000000 +0100
+++ teeworlds-0.5.2-teecomp/src/game/client/components/hud.hpp	2009-10-27 19:06:18.000000000 +0100
@@ -12,6 +12,8 @@
 	void render_voting();
 	void render_healthandammo();
 	void render_goals();
+	void render_speed();
+	void render_spectate();
 	
 public:
 	HUD();
diff -Nru teeworlds-0.5.2-src/src/game/client/components/items.cpp teeworlds-0.5.2-teecomp/src/game/client/components/items.cpp
--- teeworlds-0.5.2-src/src/game/client/components/items.cpp	2009-10-26 19:04:31.000000000 +0100
+++ teeworlds-0.5.2-teecomp/src/game/client/components/items.cpp	2009-10-27 19:06:18.000000000 +0100
@@ -12,6 +12,8 @@
 
 #include "items.hpp"
 
+#include <game/client/teecomp.hpp>
+
 void ITEMS::render_projectile(const NETOBJ_PROJECTILE *current, int itemid)
 {
 
@@ -121,10 +123,23 @@
 	float angle = 0.0f;
 	float size = 42.0f;
 
+	if(gameclient.snap.local_info && current->carried_by == gameclient.snap.local_info->cid && config.tc_hide_carrying)
+		return;
+
 	gfx_blend_normal();
-	gfx_texture_set(data->images[IMAGE_GAME].id);
+	if(config.tc_colored_flags)
+		gfx_texture_set(data->images[IMAGE_GAME_GRAY].id);
+	else
+		gfx_texture_set(data->images[IMAGE_GAME].id);
 	gfx_quads_begin();
 
+	if(config.tc_colored_flags && gameclient.snap.local_info)
+	{
+		vec3 col = TeecompUtils::getTeamColor(current->team, gameclient.snap.local_info->team,
+			config.tc_colored_tees_team1, config.tc_colored_tees_team2, config.tc_colored_tees_method);
+		gfx_setcolor(col.r, col.g, col.b, 1.0f);
+	}
+
 	if(current->team == 0) // red team
 		select_sprite(SPRITE_FLAG_RED);
 	else
@@ -169,7 +184,10 @@
 	//vec4 outer_color(0.65f,0.85f,1.0f,1.0f);
 
 	// do outline
-	vec4 outer_color(0.075f,0.075f,0.25f,1.0f);
+	vec4 outer_color(
+		(config.tc_laser_color_outer>>16)/255.0f,
+		((config.tc_laser_color_outer>>8)&0xff)/255.0f,
+		(config.tc_laser_color_outer&0xff)/255.0f, 1.0f);
 	gfx_setcolor(outer_color.r,outer_color.g,outer_color.b,1.0f);
 	out = vec2(dir.y, -dir.x) * (7.0f*ia);
 
@@ -181,7 +199,10 @@
 		);
 
 	// do inner	
-	vec4 inner_color(0.5f,0.5f,1.0f,1.0f);
+	vec4 inner_color(
+		(config.tc_laser_color_inner>>16)/255.0f,
+		((config.tc_laser_color_inner>>8)&0xff)/255.0f,
+		(config.tc_laser_color_inner&0xff)/255.0f, 1.0f);
 	out = vec2(dir.y, -dir.x) * (5.0f*ia);
 	gfx_setcolor(inner_color.r, inner_color.g, inner_color.b, 1.0f); // center
 	
diff -Nru teeworlds-0.5.2-src/src/game/client/components/items.hpp teeworlds-0.5.2-teecomp/src/game/client/components/items.hpp
--- teeworlds-0.5.2-src/src/game/client/components/items.hpp	2009-10-26 19:04:31.000000000 +0100
+++ teeworlds-0.5.2-teecomp/src/game/client/components/items.hpp	2009-10-27 19:06:18.000000000 +0100
@@ -5,9 +5,9 @@
 	void render_projectile(const NETOBJ_PROJECTILE *current, int itemid);
 	void render_pickup(const NETOBJ_PICKUP *prev, const NETOBJ_PICKUP *current);
 	void render_flag(const NETOBJ_FLAG *prev, const NETOBJ_FLAG *current);
-	void render_laser(const struct NETOBJ_LASER *current);
 	
 public:
 	virtual void on_render();
+	static void render_laser(const struct NETOBJ_LASER *current); // Bleh changing visibility + static
 };
 
diff -Nru teeworlds-0.5.2-src/src/game/client/components/killmessages.cpp teeworlds-0.5.2-teecomp/src/game/client/components/killmessages.cpp
--- teeworlds-0.5.2-src/src/game/client/components/killmessages.cpp	2009-10-26 19:04:31.000000000 +0100
+++ teeworlds-0.5.2-teecomp/src/game/client/components/killmessages.cpp	2009-10-27 19:06:18.000000000 +0100
@@ -6,6 +6,8 @@
 #include <game/client/animstate.hpp>
 #include "killmessages.hpp"
 
+#include <game/client/teecomp.hpp>
+
 void KILLMESSAGES::on_reset()
 {
 	killmsg_current = 0;
@@ -67,11 +69,22 @@
 			if(killmsgs[r].mode_special&1)
 			{
 				gfx_blend_normal();
-				gfx_texture_set(data->images[IMAGE_GAME].id);
+				if(config.tc_colored_flags)
+					gfx_texture_set(data->images[IMAGE_GAME_GRAY].id);
+				else
+					gfx_texture_set(data->images[IMAGE_GAME].id);
 				gfx_quads_begin();
 
 				if(gameclient.clients[killmsgs[r].victim].team == 0) select_sprite(SPRITE_FLAG_BLUE);
 				else select_sprite(SPRITE_FLAG_RED);
+				if(config.tc_colored_flags)
+				{
+					vec3 col = TeecompUtils::getTeamColor(1-gameclient.clients[killmsgs[r].victim].team,
+						gameclient.snap.local_info->team,
+						config.tc_colored_tees_team1, config.tc_colored_tees_team2,
+						config.tc_colored_tees_method);
+					gfx_setcolor(col.r, col.g, col.b, 1.0f);
+				}
 				
 				float size = 56.0f;
 				gfx_quads_drawTL(x, y-16, size/2, size);
@@ -101,11 +114,22 @@
 				if(killmsgs[r].mode_special&2)
 				{
 					gfx_blend_normal();
-					gfx_texture_set(data->images[IMAGE_GAME].id);
+					if(config.tc_colored_flags)
+						gfx_texture_set(data->images[IMAGE_GAME_GRAY].id);
+					else
+						gfx_texture_set(data->images[IMAGE_GAME].id);
 					gfx_quads_begin();
 
 					if(gameclient.clients[killmsgs[r].killer].team == 0) select_sprite(SPRITE_FLAG_BLUE, SPRITE_FLAG_FLIP_X);
 					else select_sprite(SPRITE_FLAG_RED, SPRITE_FLAG_FLIP_X);
+					if(config.tc_colored_flags)
+					{
+						vec3 col = TeecompUtils::getTeamColor(1-gameclient.clients[killmsgs[r].killer].team,
+							gameclient.snap.local_info->team,
+							config.tc_colored_tees_team1, config.tc_colored_tees_team2,
+							config.tc_colored_tees_method);
+						gfx_setcolor(col.r, col.g, col.b, 1.0f);
+					}
 					
 					float size = 56.0f;
 					gfx_quads_drawTL(x-56, y-16, size/2, size);
diff -Nru teeworlds-0.5.2-src/src/game/client/components/menus.hpp teeworlds-0.5.2-teecomp/src/game/client/components/menus.hpp
--- teeworlds-0.5.2-src/src/game/client/components/menus.hpp	2009-10-26 19:04:31.000000000 +0100
+++ teeworlds-0.5.2-teecomp/src/game/client/components/menus.hpp	2009-10-27 19:06:18.000000000 +0100
@@ -3,6 +3,12 @@
 #include <game/client/component.hpp>
 #include <game/client/ui.hpp>
 
+typedef struct 
+{
+	const char *name;
+	const char *command;
+	int keyid;
+} KEYINFO;
 
 // compnent to fetch keypresses, override all other input
 class MENUS_KEYBINDER : public COMPONENT
@@ -162,6 +168,14 @@
 	void render_settings_graphics(RECT main_view);
 	void render_settings_sound(RECT main_view);
 	void render_settings(RECT main_view);
+	// TeeComp related
+	void render_rgb_sliders(RECT* main_view, RECT* button, int &r, int &g, int &b, bool enabled);
+	void ui_do_keybinder(KEYINFO& key, RECT* r);
+	void render_settings_teecomp(RECT main_view);
+	void render_settings_teecomp_skins(RECT main_view);
+	void render_settings_teecomp_stats(RECT main_view);
+	void render_settings_teecomp_misc(RECT main_view);
+	void render_settings_teecomp_about(RECT main_view);
 	
 	void set_active(bool active);
 public:
@@ -181,3 +195,4 @@
 	virtual bool on_input(INPUT_EVENT e);
 	virtual bool on_mousemove(float x, float y);
 };
+
diff -Nru teeworlds-0.5.2-src/src/game/client/components/menus_ingame.cpp teeworlds-0.5.2-teecomp/src/game/client/components/menus_ingame.cpp
--- teeworlds-0.5.2-src/src/game/client/components/menus_ingame.cpp	2009-10-26 19:04:31.000000000 +0100
+++ teeworlds-0.5.2-teecomp/src/game/client/components/menus_ingame.cpp	2009-10-27 19:06:18.000000000 +0100
@@ -13,6 +13,8 @@
 #include <game/client/gameclient.hpp>
 #include <game/client/animstate.hpp>
 
+#include <game/client/teecomp.hpp>
+
 #include "menus.hpp"
 #include "motd.hpp"
 #include "voting.hpp"
@@ -49,12 +51,17 @@
 		
 		if(gameclient.snap.gameobj->flags & GAMEFLAG_TEAMS)
 		{
+			char buf[32];
 			if(gameclient.snap.local_info->team != 0)
 			{
 				ui_vsplit_l(&main_view, 10.0f, &button, &main_view);
 				ui_vsplit_l(&main_view, 120.0f, &button, &main_view);
 				static int spectate_button = 0;
-				if(ui_do_button(&spectate_button, "Join Red", 0, &button, ui_draw_menu_button, 0))
+				if(gameclient.snap.local_info->team == -1 || config.tc_colored_tees_method == 0)
+					str_format(buf, sizeof(buf), "Join %s", TeecompUtils::rgb_to_name(config.tc_colored_tees_team1));
+				else
+					str_format(buf, sizeof(buf), "Join %s", TeecompUtils::rgb_to_name(config.tc_colored_tees_team2));
+				if(ui_do_button(&spectate_button, buf, 0, &button, ui_draw_menu_button, 0))
 				{
 					gameclient.send_switch_team(0);
 					set_active(false);
@@ -66,7 +73,8 @@
 				ui_vsplit_l(&main_view, 10.0f, &button, &main_view);
 				ui_vsplit_l(&main_view, 120.0f, &button, &main_view);
 				static int spectate_button = 0;
-				if(ui_do_button(&spectate_button, "Join Blue", 0, &button, ui_draw_menu_button, 0))
+				str_format(buf, sizeof(buf), "Join %s", TeecompUtils::rgb_to_name(config.tc_colored_tees_team2));
+				if(ui_do_button(&spectate_button, buf, 0, &button, ui_draw_menu_button, 0))
 				{
 					gameclient.send_switch_team(1);
 					set_active(false);
diff -Nru teeworlds-0.5.2-src/src/game/client/components/menus_settings.cpp teeworlds-0.5.2-teecomp/src/game/client/components/menus_settings.cpp
--- teeworlds-0.5.2-src/src/game/client/components/menus_settings.cpp	2009-10-26 19:04:31.000000000 +0100
+++ teeworlds-0.5.2-teecomp/src/game/client/components/menus_settings.cpp	2009-10-27 19:06:18.000000000 +0100
@@ -241,13 +241,6 @@
 
 typedef void (*assign_func_callback)(CONFIGURATION *config, int value);
 
-typedef struct 
-{
-	const char *name;
-	const char *command;
-	int keyid;
-} KEYINFO;
-
 KEYINFO keys[] = 
 {
 	{ "Move Left:", "+left", 0},
@@ -636,7 +629,7 @@
 	
 	RECT button;
 	
-	const char *tabs[] = {"Player", "Controls", "Graphics", "Sound"};
+	const char *tabs[] = {"Player", "Controls", "Graphics", "Sound", "TeeComp"};
 	int num_tabs = (int)(sizeof(tabs)/sizeof(*tabs));
 
 	for(int i = 0; i < num_tabs; i++)
@@ -657,8 +650,10 @@
 		render_settings_graphics(main_view);
 	else if(settings_page == 3)
 		render_settings_sound(main_view);
+	else if(settings_page == 4)
+		render_settings_teecomp(main_view);
 
-	if(need_restart)
+	if(need_restart && settings_page != 4)
 	{
 		RECT restart_warning;
 		ui_hsplit_b(&main_view, 40, &main_view, &restart_warning);
diff -Nru teeworlds-0.5.2-src/src/game/client/components/menus_teecomp.cpp teeworlds-0.5.2-teecomp/src/game/client/components/menus_teecomp.cpp
--- teeworlds-0.5.2-src/src/game/client/components/menus_teecomp.cpp	1970-01-01 01:00:00.000000000 +0100
+++ teeworlds-0.5.2-teecomp/src/game/client/components/menus_teecomp.cpp	2009-10-27 19:41:48.000000000 +0100
@@ -0,0 +1,555 @@
+#include <string.h>
+
+#include <engine/e_client_interface.h>
+
+#include <game/generated/g_protocol.hpp>
+#include <game/generated/gc_data.hpp>
+
+#include <game/version.hpp>
+#include <game/client/ui.hpp>
+#include <game/client/render.hpp>
+#include <game/client/gameclient.hpp>
+#include <game/client/animstate.hpp>
+
+#include "binds.hpp"
+#include "menus.hpp"
+#include "skins.hpp"
+#include "items.hpp"
+
+#include <game/client/teecomp.hpp>
+
+void MENUS::render_rgb_sliders(RECT* main_view, RECT* button, int &r, int &g, int &b, bool enabled)
+{
+	const char *labels[] = {"R.", "G.", "B."};
+	int *color_slider[3] = {&r, &g, &b};
+	for(int i=0; i<3; i++)
+	{
+		RECT text;
+		ui_hsplit_t(main_view, 19.0f, button, main_view);
+		ui_vmargin(button, 15.0f, button);
+		ui_vsplit_l(button, 30.0f, &text, button);
+		ui_vsplit_r(button, 5.0f, button, 0);
+		ui_hsplit_t(button, 4.0f, 0, button);
+
+		if(enabled)
+		{
+			float k = (*color_slider[i]) / 255.0f;
+			k = ui_do_scrollbar_h(color_slider[i], button, k);
+			*color_slider[i] = (int)(k*255.0f);
+		}
+		else
+			ui_do_scrollbar_h(color_slider[i], button, 0);
+		ui_do_label(&text, labels[i], 15.0f, -1);
+	}
+}
+
+void MENUS::ui_do_keybinder(KEYINFO& key, RECT* r)
+{
+	RECT label, button;
+	ui_hsplit_t(r, 20.0f, &button, r);
+	ui_vsplit_r(&button, 5.0f, &button, 0);
+	ui_vsplit_l(&button, 130.0f, &label, &button);
+
+	ui_do_label(&label, key.name, 14.0f, -1);
+	int oldid = key.keyid;
+	int newid = ui_do_key_reader((void *)key.name, &button, oldid);
+	if(newid != oldid)
+	{
+		gameclient.binds->bind(oldid, "");
+		gameclient.binds->bind(newid, key.command);
+	}
+	ui_hsplit_t(r, 5.0f, 0, r);
+}
+
+void MENUS::render_settings_teecomp(RECT main_view)
+{
+	RECT button;
+	static int settings_page = 0;
+
+	if(settings_page != 3)
+	{
+		ui_hsplit_b(&main_view, 20.0f, 0, &button);
+		ui_vsplit_l(&button, main_view.w/3, &button, 0);
+		static int default_button = 0;
+		if(ui_do_button((void*)&default_button, "Reset to defaults", 0, &button, ui_draw_menu_button, 0))
+			TeecompUtils::reset_config();
+
+		ui_hsplit_b(&main_view, 10.0f, &main_view, &button);
+		ui_do_label(&button, "http://spl0k.unreal-design.com/teeworlds/", 10.0f, 1);
+		ui_hsplit_b(&main_view, 10.0f, &main_view, &button);
+		char buf[64];
+		str_format(buf, sizeof(buf), "Teeworlds %s with TeeComp %s by spl0k", GAME_VERSION, TEECOMP_VERSION);
+		ui_do_label(&button, buf, 10.0f, 1);
+		ui_hsplit_b(&main_view, 10.0f, &main_view, 0);
+	}
+
+	// render background
+	RECT tabbar;
+	ui_hsplit_t(&main_view, 24.0f, &tabbar, &main_view);
+	//ui_draw_rect(&main_view, color_tabbar_active, CORNER_ALL, 10.0f);
+
+	const char *tabs[] = {"Skins", "Stats", "Misc", "About"};
+	int num_tabs = (int)(sizeof(tabs)/sizeof(*tabs));
+
+	for(int i=0; i<num_tabs; i++)
+	{
+		ui_vsplit_l(&tabbar, 10.0f, &button, &tabbar);
+		ui_vsplit_l(&tabbar, 80.0f, &button, &tabbar);
+		int corners = CORNER_ALL;
+		if(ui_do_button(tabs[i], tabs[i], settings_page == i, &button, ui_draw_menu_tab_button, &corners))
+			settings_page = i;
+	}
+
+	if(settings_page != 3)
+		ui_margin(&main_view, 10.0f, &main_view);
+	
+	if(settings_page == 0)
+		render_settings_teecomp_skins(main_view);
+	else if(settings_page == 1)
+		render_settings_teecomp_stats(main_view);
+	else if(settings_page == 2)
+		render_settings_teecomp_misc(main_view);
+	else if(settings_page == 3)
+		render_settings_teecomp_about(main_view);
+}
+
+void MENUS::render_settings_teecomp_skins(RECT main_view)
+{
+	RECT button, left_view, right_view;
+	ui_vsplit_l(&main_view, main_view.w/2, &left_view, &right_view);
+
+	ui_hsplit_t(&left_view, 20.0f, &button, &left_view);
+	if(ui_do_button(&config.tc_colored_tees_method, "Enemy based colors", config.tc_colored_tees_method, &button, ui_draw_checkbox, 0))
+		config.tc_colored_tees_method ^= 1;
+
+	// Colors team 1
+
+	ui_hsplit_t(&left_view, 20.0f, &button, &left_view);
+	char buf[128];
+	str_format(buf, sizeof(buf), "Use DM colors for team %s", (config.tc_colored_tees_method)?"mates":"1");
+	if(ui_do_button(&config.tc_dm_colors_team1, buf, config.tc_dm_colors_team1, &button, ui_draw_checkbox, 0))
+		config.tc_dm_colors_team1 ^= 1;
+
+	ui_hsplit_t(&left_view, 20.0f, &button, &left_view);
+	ui_do_label(&button, (config.tc_colored_tees_method)?"Team mates":"Team 1", 14.0f, -1);
+	int r1, g1, b1, r2, g2, b2;
+	r1 = config.tc_colored_tees_team1>>16;
+	g1 = (config.tc_colored_tees_team1>>8)&0xff;
+	b1 = config.tc_colored_tees_team1&0xff;
+	render_rgb_sliders(&left_view, &button, r1, g1, b1, !config.tc_dm_colors_team1);
+	config.tc_colored_tees_team1 = (r1<<16) + (g1<<8) + b1;
+
+	const SKINS::SKIN *s = gameclient.skins->get(max(0, gameclient.skins->find(config.tc_forced_skin1)));
+	TEE_RENDER_INFO info;
+	if(!config.tc_dm_colors_team1)
+	{
+		info.texture = s->color_texture;
+		info.color_body = vec4(r1/255.0f, g1/255.0f, b1/255.0f, 1.0f);
+		info.color_feet = vec4(r1/255.0f, g1/255.0f, b1/255.0f, 1.0f);
+	}
+	else
+	{
+		info.texture = s->org_texture;
+		info.color_body = vec4(1.0f, 1.0f, 1.0f, 1.0f);
+		info.color_feet = vec4(1.0f, 1.0f, 1.0f, 1.0f);
+	}
+	info.size = ui_scale()*50.f;
+
+	ui_hsplit_t(&button, 70.0f, 0, &button);
+	render_tee(ANIMSTATE::get_idle(), &info, 0, vec2(1, 0), vec2(button.x, button.y+button.h/2));
+	ui_hsplit_t(&left_view, 50.0f, 0, &left_view);
+
+	// Colors team 2
+
+	ui_hsplit_t(&right_view, 20.0f, 0, &right_view);
+	ui_hsplit_t(&right_view, 20.0f, &button, &right_view);
+	str_format(buf, sizeof(buf), "Use DM colors for %s", (config.tc_colored_tees_method)?"enemies":"team 2");
+	if(ui_do_button(&config.tc_dm_colors_team2, buf, config.tc_dm_colors_team2, &button, ui_draw_checkbox, 0))
+		config.tc_dm_colors_team2 ^= 1;
+
+	ui_hsplit_t(&right_view, 20.0f, &button, &right_view);
+	ui_do_label(&button, (config.tc_colored_tees_method)?"Enemies":"Team 2", 14.0f, -1);
+	r2 = config.tc_colored_tees_team2>>16;
+	g2 = (config.tc_colored_tees_team2>>8)&0xff;
+	b2 = config.tc_colored_tees_team2&0xff;
+	render_rgb_sliders(&right_view, &button, r2, g2, b2, !config.tc_dm_colors_team2);
+	config.tc_colored_tees_team2 = (r2<<16) + (g2<<8) + b2;
+
+	s = gameclient.skins->get(max(0, gameclient.skins->find(config.tc_forced_skin2)));
+	if(!config.tc_dm_colors_team2)
+	{
+		info.texture = s->color_texture;
+		info.color_body = vec4(r2/255.0f, g2/255.0f, b2/255.0f, 1.0f);
+		info.color_feet = vec4(r2/255.0f, g2/255.0f, b2/255.0f, 1.0f);
+	}
+	else
+	{
+		info.texture = s->org_texture;
+		info.color_body = vec4(1.0f, 1.0f, 1.0f, 1.0f);
+		info.color_feet = vec4(1.0f, 1.0f, 1.0f, 1.0f);
+	}
+
+	ui_hsplit_t(&button, 70.0f, 0, &button);
+	render_tee(ANIMSTATE::get_idle(), &info, 0, vec2(1, 0), vec2(button.x, button.y+button.h/2));
+	ui_hsplit_t(&right_view, 50.0f, 0, &right_view);
+
+	// Force skins team 1
+
+	ui_hsplit_t(&left_view, 20.0f, &button, &left_view);
+	if(ui_do_button(&config.tc_forced_skins_method, "Enemy based skins", config.tc_forced_skins_method, &button, ui_draw_checkbox, 0))
+		config.tc_forced_skins_method ^= 1;
+
+	ui_hsplit_t(&left_view, 20.0f, &button, &left_view);
+	str_format(buf, sizeof(buf), "Force team %s/FFA skins", (config.tc_forced_skins_method)?"mates":"1");
+	if(ui_do_button(&config.tc_force_skin_team1, buf, config.tc_force_skin_team1, &button, ui_draw_checkbox, 0))
+		config.tc_force_skin_team1 ^= 1;
+
+	RECT skinselection, scroll;
+	ui_margin(&left_view, 10.0f, &skinselection);
+
+	ui_hsplit_t(&skinselection, 20, &button, &skinselection);
+	ui_draw_rect(&button, vec4(1,1,1,0.25f), CORNER_T, 5.0f); 
+	ui_do_label(&button, "Forced skin", 14.0f, 0);
+
+	ui_draw_rect(&skinselection, vec4(0,0,0,0.15f), 0, 0);
+	ui_vsplit_r(&skinselection, 15, &skinselection, &scroll);
+
+	RECT list = skinselection;
+	ui_hsplit_t(&list, 20, &button, &list);
+	
+	int num = (int)(skinselection.h/button.h);
+	static float scrollvalue = 0;
+	static int scrollbar = 0;
+	ui_hmargin(&scroll, 5.0f, &scroll);
+	scrollvalue = ui_do_scrollbar_v(&scrollbar, &scroll, scrollvalue);
+
+	int start = (int)((gameclient.skins->num()-num)*scrollvalue);
+	if(start < 0)
+		start = 0;
+
+	for(int i=start; i<start+num && i<gameclient.skins->num(); i++)
+	{
+		const SKINS::SKIN *s = gameclient.skins->get(i);
+
+		str_format(buf, sizeof(buf), "%s", s->name);
+		int selected = 0;
+		if(strcmp(s->name, config.tc_forced_skin1) == 0)
+			selected = 1;
+
+		if(ui_do_button(s, "", selected, &button, ui_draw_list_row, 0))
+			str_copy(config.tc_forced_skin1, s->name, sizeof(config.tc_forced_skin1));
+
+		ui_vmargin(&button, 5.0f, &button);
+		ui_hsplit_t(&button, 1.0f, 0, &button);
+		ui_do_label(&button, buf, 14.0f, -1);
+
+		ui_hsplit_t(&list, 20.0f, &button, &list);
+	}
+
+	// Forced skin team 2
+
+	ui_hsplit_t(&right_view, 20.0f, 0, &right_view);
+	ui_hsplit_t(&right_view, 20.0f, &button, &right_view);
+	str_format(buf, sizeof(buf), "Force %s skins", (config.tc_forced_skins_method)?"enemies":"team 2");
+	if(ui_do_button(&config.tc_force_skin_team2, buf, config.tc_force_skin_team2, &button, ui_draw_checkbox, 0))
+		config.tc_force_skin_team2 ^= 1;
+
+	ui_margin(&right_view, 10.0f, &skinselection);
+
+	ui_hsplit_t(&skinselection, 20, &button, &skinselection);
+	ui_draw_rect(&button, vec4(1,1,1,0.25f), CORNER_T, 5.0f); 
+	ui_do_label(&button, "Forced skin", 14.0f, 0);
+
+	ui_draw_rect(&skinselection, vec4(0,0,0,0.15f), 0, 0);
+	ui_vsplit_r(&skinselection, 15, &skinselection, &scroll);
+
+	list = skinselection;
+	ui_hsplit_t(&list, 20, &button, &list);
+	
+	num = (int)(skinselection.h/button.h);
+	static float scrollvalue2 = 0;
+	static int scrollbar2 = 0;
+	ui_hmargin(&scroll, 5.0f, &scroll);
+	scrollvalue2 = ui_do_scrollbar_v(&scrollbar2, &scroll, scrollvalue2);
+
+	start = (int)((gameclient.skins->num()-num)*scrollvalue2);
+	if(start < 0)
+		start = 0;
+
+	for(int i=start; i<start+num && i<gameclient.skins->num(); i++)
+	{
+		const SKINS::SKIN *s = gameclient.skins->get(i);
+
+		str_format(buf, sizeof(buf), "%s", s->name);
+		int selected = 0;
+		if(strcmp(s->name, config.tc_forced_skin2) == 0)
+			selected = 1;
+
+		if(ui_do_button(s+gameclient.skins->num(), "", selected, &button, ui_draw_list_row, 0))
+			str_copy(config.tc_forced_skin2, s->name, sizeof(config.tc_forced_skin2));
+
+		ui_vmargin(&button, 5.0f, &button);
+		ui_hsplit_t(&button, 1.0f, 0, &button);
+		ui_do_label(&button, buf, 14.0f, -1);
+
+		ui_hsplit_t(&list, 20.0f, &button, &list);
+	}
+}
+
+void MENUS::render_settings_teecomp_stats(RECT main_view)
+{
+	RECT button, left_view;
+
+	ui_vsplit_l(&main_view, main_view.w/2, &left_view, &main_view);
+
+	ui_hsplit_t(&left_view, 20.0f, &button, &left_view);
+	ui_do_label(&button, "Show in global statboard:", 16.0f, -1);
+
+	ui_hsplit_t(&left_view, 20.0f, &button, &left_view);
+	if(ui_do_button(&config.tc_statboard_infos, "Frags", config.tc_statboard_infos & TC_STATS_FRAGS, &button, ui_draw_checkbox, 0))
+		config.tc_statboard_infos ^= TC_STATS_FRAGS;
+
+	ui_hsplit_t(&left_view, 20.0f, &button, &left_view);
+	if(ui_do_button(&config.tc_statboard_infos+1, "Deaths", config.tc_statboard_infos & TC_STATS_DEATHS, &button, ui_draw_checkbox, 0))
+		config.tc_statboard_infos ^= TC_STATS_DEATHS;
+
+	ui_hsplit_t(&left_view, 20.0f, &button, &left_view);
+	if(ui_do_button(&config.tc_statboard_infos+2, "Suicides", config.tc_statboard_infos & TC_STATS_SUICIDES, &button, ui_draw_checkbox, 0))
+		config.tc_statboard_infos ^= TC_STATS_SUICIDES;
+
+	ui_hsplit_t(&left_view, 20.0f, &button, &left_view);
+	if(ui_do_button(&config.tc_statboard_infos+3, "Ratio", config.tc_statboard_infos & TC_STATS_RATIO, &button, ui_draw_checkbox, 0))
+		config.tc_statboard_infos ^= TC_STATS_RATIO;
+
+	ui_hsplit_t(&left_view, 20.0f, &button, &left_view);
+	if(ui_do_button(&config.tc_statboard_infos+4, "Net score", config.tc_statboard_infos & TC_STATS_NET, &button, ui_draw_checkbox, 0))
+		config.tc_statboard_infos ^= TC_STATS_NET;
+
+	ui_hsplit_t(&left_view, 20.0f, &button, &left_view);
+	if(ui_do_button(&config.tc_statboard_infos+5, "Frags per minute", config.tc_statboard_infos & TC_STATS_FPM, &button, ui_draw_checkbox, 0))
+		config.tc_statboard_infos ^= TC_STATS_FPM;
+
+	ui_hsplit_t(&left_view, 20.0f, &button, &left_view);
+	if(ui_do_button(&config.tc_statboard_infos+6, "Weapons stats", config.tc_statboard_infos & TC_STATS_WEAPS, &button, ui_draw_checkbox, 0))
+		config.tc_statboard_infos ^= TC_STATS_WEAPS;
+
+	ui_hsplit_t(&left_view, 20.0f, &button, &left_view);
+	if(ui_do_button(&config.tc_statboard_infos+7, "Flag captures", config.tc_statboard_infos & TC_STATS_FLAGS, &button, ui_draw_checkbox, 0))
+		config.tc_statboard_infos ^= TC_STATS_FLAGS;
+
+	ui_hsplit_t(&main_view, 20.0f, &button, &main_view);
+	ui_do_label(&button, "Key bindings:", 16.0f, -1);
+	KEYINFO keys[] = {{ "Global statboard:", "+stats 1", 0},
+		{ "Individual statboard:", "+stats 2", 0},
+		{ "Next individual stats:", "+next_stats", 0}};
+
+	for(int keyid=0; keyid<KEY_LAST; keyid++)
+	{
+		const char *bind = gameclient.binds->get(keyid);
+		if(!bind[0])
+			continue;
+
+		for(int i=0; i<sizeof(keys)/sizeof(KEYINFO); i++)
+			if(strcmp(bind, keys[i].command) == 0)
+			{
+				keys[i].keyid = keyid;
+				break;
+			}
+	}
+
+	for(int i=0; i<sizeof(keys)/sizeof(KEYINFO); i++)
+		ui_do_keybinder(keys[i], &main_view);
+}
+
+void MENUS::render_settings_teecomp_misc(RECT main_view)
+{
+	RECT left_view, right_view, button;
+
+	ui_vsplit_l(&main_view, main_view.w/2, &left_view, &right_view);
+
+	ui_hsplit_t(&main_view, 20.0f, &button, &main_view);
+	ui_do_label(&button, "Name plates", 16.0f, 0);
+	ui_hsplit_t(&left_view, 20.0f, 0, &left_view);
+	ui_hsplit_t(&right_view, 20.0f, 0, &right_view);
+
+	ui_hsplit_t(&left_view, 20.0f, &button, &left_view);
+	if(ui_do_button(&config.tc_colored_nameplates, "Colored name plates", config.tc_colored_nameplates&1, &button, ui_draw_checkbox, 0))
+		config.tc_colored_nameplates ^= 1;
+
+	ui_hsplit_t(&right_view, 20.0f, &button, &right_view);
+	if(ui_do_button(&config.tc_colored_nameplates+1, "Enemy based colors", config.tc_colored_nameplates&2, &button, ui_draw_checkbox, 0))
+		config.tc_colored_nameplates ^= 2;
+
+	ui_hsplit_t(&left_view, 20.0f, &button, &left_view);
+	ui_do_label(&button, (config.tc_colored_nameplates&2)?"Team mates":"Team 1", 14.0f, -1);
+	int r1, g1, b1, r2, g2, b2;
+	r1 = config.tc_colored_nameplates_team1>>16;
+	g1 = (config.tc_colored_nameplates_team1>>8)&0xff;
+	b1 = config.tc_colored_nameplates_team1&0xff;
+	render_rgb_sliders(&left_view, &button, r1, g1, b1, true);
+	config.tc_colored_nameplates_team1 = (r1<<16) + (g1<<8) + b1;
+
+	ui_hsplit_t(&left_view, 25.0f, &button, &left_view);
+	ui_vsplit_l(&button, 30.0f, 0, &button);
+	gfx_text_color(r1/255.0f, g1/255.0f, b1/255.0f, 1);
+	ui_do_label(&button, (config.tc_colored_nameplates&2)?"Team mates":"Team 1", 15.0f, -1);
+	gfx_text_color(1,1,1,1);
+
+	ui_hsplit_t(&right_view, 20.0f, &button, &right_view);
+	ui_do_label(&button, (config.tc_colored_nameplates&2)?"Enemies":"Team 2", 14.0f, -1);
+	r2 = config.tc_colored_nameplates_team2>>16;
+	g2 = (config.tc_colored_nameplates_team2>>8)&0xff;
+	b2 = config.tc_colored_nameplates_team2&0xff;
+	render_rgb_sliders(&right_view, &button, r2, g2, b2, true);
+	config.tc_colored_nameplates_team2 = (r2<<16) + (g2<<8) + b2;
+
+	ui_hsplit_t(&right_view, 25.0f, &button, &right_view);
+	ui_vsplit_l(&button, 30.0f, 0, &button);
+	gfx_text_color(r2/255.0f, g2/255.0f, b2/255.0f, 1);
+	ui_do_label(&button, (config.tc_colored_nameplates&2)?"Enemies":"Team 2", 15.0f, -1);
+	gfx_text_color(1,1,1,1);
+
+	ui_hsplit_t(&left_view, 20.0f, &button, &left_view);
+	if(ui_do_button(&config.tc_nameplate_shadow, "Show name plate shadow", config.tc_nameplate_shadow, &button, ui_draw_checkbox, 0))
+		config.tc_nameplate_shadow ^= 1;
+
+	ui_hsplit_t(&right_view, 20.0f, &button, &right_view);
+	if(ui_do_button(&config.tc_nameplate_score, "Show score in name plate", config.tc_nameplate_score, &button, ui_draw_checkbox, 0))
+		config.tc_nameplate_score ^= 1;
+
+	ui_hsplit_t(&main_view, 160.0f, 0, &main_view);
+	ui_hsplit_t(&main_view, 20.0f, &button, &main_view);
+	ui_do_label(&button, "Laser", 16.0f, 0);
+	ui_hsplit_t(&left_view, 40.0f, 0, &left_view);
+	ui_hsplit_t(&right_view, 40.0f, 0, &right_view);
+
+	int lri, lro, lgi, lgo, lbi, lbo;
+	lri = config.tc_laser_color_inner>>16;
+	lgi = (config.tc_laser_color_inner>>8)&0xff;
+	lbi = config.tc_laser_color_inner&0xff;
+	ui_hsplit_t(&left_view, 20.0f, &button, &left_view);
+	ui_do_label(&button, "Laser inner color", 14.0f, -1);
+	render_rgb_sliders(&left_view, &button, lri, lgi, lbi, true);
+	config.tc_laser_color_inner = (lri<<16) + (lgi<<8) + lbi;
+
+	lro = config.tc_laser_color_outer>>16;
+	lgo = (config.tc_laser_color_outer>>8)&0xff;
+	lbo = config.tc_laser_color_outer&0xff;
+	ui_hsplit_t(&right_view, 20.0f, &button, &right_view);
+	ui_do_label(&button, "Laser outer color", 14.0f, -1);
+	render_rgb_sliders(&right_view, &button, lro, lgo, lbo, true);
+	config.tc_laser_color_outer = (lro<<16) + (lgo<<8) + lbo;
+
+	{ RECT lbut, rbut;
+	RECT screen = *ui_screen();
+	ui_hsplit_t(&left_view, 20.0f, &lbut, &left_view);
+	ui_hsplit_t(&right_view, 20.0f, &rbut, &right_view);
+	// calculate world screen mapping
+	float points[4];
+	mapscreen_to_world(0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, gfx_screenaspect(), 1.0f, points);
+	points[2] = points[2] - points[0];
+	points[3] = points[3] - points[1];
+	points[0] = 0.0f;
+	points[1] = 0.0f;
+	// factor between world and menu screen mappings
+	float fact_x, fact_y;
+	fact_x = (points[2]-points[0])/screen.w;
+	fact_y = (points[3]-points[1])/screen.h;
+	struct NETOBJ_LASER laser;
+	// we want to draw a beam from under the center of one sliders section to the center of the other sliders section
+	laser.from_x = (lbut.x + lbut.w/2)*fact_x;
+	laser.from_y = (lbut.y + lbut.h/2)*fact_y;
+	laser.x = (rbut.x + rbut.w/2)*fact_x;
+	laser.y = (rbut.y + rbut.h/2)*fact_y;
+	laser.start_tick = client_tick() + client_intratick();
+	// apply world screen mapping (beam is bigger in menu mapping)
+	gfx_mapscreen(points[0], points[1], points[2], points[3]);
+	// draw laser
+	ITEMS::render_laser(&laser);
+	// restore menu screen mapping
+	gfx_mapscreen(screen.x, screen.y, screen.w, screen.h); }
+
+	ui_hsplit_t(&left_view, 20.0f, 0, &left_view);
+	ui_hsplit_t(&left_view, 20.0f, &button, &left_view);
+	ui_do_label(&button, "HUD/Flag", 16.0f, -1);
+
+	ui_hsplit_t(&left_view, 20.0f, &button, &left_view);
+	if(ui_do_button(&config.tc_hud_match, "Make HUD match tees colors", config.tc_hud_match, &button, ui_draw_checkbox, 0))
+		config.tc_hud_match ^= 1;
+
+	ui_hsplit_t(&left_view, 20.0f, &button, &left_view);
+	if(ui_do_button(&config.tc_colored_flags, "Make flags match tees colors", config.tc_colored_flags, &button, ui_draw_checkbox, 0))
+		config.tc_colored_flags ^= 1;
+
+	ui_hsplit_t(&left_view, 20.0f, &button, &left_view);
+	if(ui_do_button(&config.tc_speedmeter, "Display speed meter", config.tc_speedmeter, &button, ui_draw_checkbox, 0))
+		config.tc_speedmeter ^= 1;
+
+	ui_hsplit_t(&left_view, 20.0f, &button, &left_view);
+	ui_vsplit_l(&button, 15.0f, 0, &button);
+	if(ui_do_button(&config.tc_speedmeter_accel, "Speed meter show acceleration", config.tc_speedmeter_accel, &button, ui_draw_checkbox, 0))
+		config.tc_speedmeter_accel ^= 1;
+
+	ui_hsplit_t(&right_view, 20.0f, 0, &right_view);
+	ui_hsplit_t(&right_view, 20.0f, &button, &right_view);
+	ui_do_label(&button, "Others", 16.0f, -1);
+
+	ui_hsplit_t(&right_view, 20.0f, &button, &right_view);
+	if(ui_do_button(&config.tc_disable_chat, "Disable chat", config.tc_disable_chat, &button, ui_draw_checkbox, 0))
+		config.tc_disable_chat ^= 1;
+
+	ui_hsplit_t(&right_view, 20.0f, &button, &right_view);
+	if(ui_do_button(&config.tc_hide_carrying, "Hide flag while carrying it", config.tc_hide_carrying, &button, ui_draw_checkbox, 0))
+		config.tc_hide_carrying ^= 1;
+
+	ui_hsplit_t(&right_view, 20.0f, &button, &right_view);
+	if(ui_do_button(&config.tc_autodemo, "Enable automatic demo recording", config.tc_autodemo, &button, ui_draw_checkbox, 0))
+		config.tc_autodemo ^= 1;
+
+	ui_hsplit_t(&right_view, 20.0f, &button, &right_view);
+	if(ui_do_button(&config.tc_autoscreen, "Enable end game automatic screenshot", config.tc_autoscreen, &button, ui_draw_checkbox, 0))
+		config.tc_autoscreen ^= 1;
+}
+
+void MENUS::render_settings_teecomp_about(RECT main_view)
+{
+	RECT button;
+
+	ui_hsplit_t(&main_view, 52.0f, &button, &main_view);
+	ui_do_label(&button, "TeeComp", 48.0f, 0);
+	ui_hsplit_t(&main_view, 20.0f, &button, &main_view);
+	ui_vsplit_r(&button, button.w/3, 0, &button);
+	ui_do_label(&button, "Version "TEECOMP_VERSION, 14.0f, -1);
+	ui_hsplit_t(&main_view, 20.0f, &button, &main_view);
+	ui_vsplit_r(&button, button.w/3, 0, &button);
+	ui_do_label(&button, "For Teeworlds "GAME_VERSION, 14.0f, -1);
+	ui_hsplit_t(&main_view, 20.0f, &button, &main_view);
+	ui_vsplit_r(&button, button.w/3, 0, &button);
+	ui_do_label(&button, "Compiled "__DATE__" "__TIME__, 14.0f, -1);
+
+	ui_hsplit_t(&main_view, 40.0f, 0, &main_view);
+	ui_hsplit_t(&main_view, 20.0f, &button, &main_view);
+	ui_do_label(&button, "By Alban 'spl0k' FERON", 14.0f, 0);
+	ui_hsplit_t(&main_view, 20.0f, &button, &main_view);
+	ui_do_label(&button, "http://spl0k.unreal-design.com/", 14.0f, 0);
+
+	ui_hsplit_t(&main_view, 20.0f, 0, &main_view);
+	ui_hsplit_t(&main_view, 22.0f, &button, &main_view);
+	ui_do_label(&button, "Special thanks to:", 16.0f, 0);
+	ui_hsplit_t(&main_view, 20.0f, &button, &main_view);
+	ui_do_label(&button, "Sd`", 14.0f, 0);
+	ui_hsplit_t(&main_view, 20.0f, &button, &main_view);
+	ui_do_label(&button, "Tho", 14.0f, 0);
+	ui_hsplit_t(&main_view, 20.0f, &button, &main_view);
+	ui_do_label(&button, "Eve", 14.0f, 0);
+	ui_hsplit_t(&main_view, 20.0f, &button, &main_view);
+	ui_do_label(&button, "some other MonkeyStyle members", 14.0f, 0);
+	ui_hsplit_t(&main_view, 20.0f, &button, &main_view);
+	ui_do_label(&button, "and the Teeworlds.com community", 14.0f, 0);
+
+	ui_hsplit_b(&main_view, 10.0f, &main_view, &button);
+	ui_do_label(&button, "so you can set while u set while u set options", 10.0f, -1);
+	ui_hsplit_b(&main_view, 10.0f, &main_view, &button);
+	ui_do_label(&button, "Yo dawg I herd you like tabs so we put tabs in yo tabs in yo tabs", 10.0f, -1);
+}
+
diff -Nru teeworlds-0.5.2-src/src/game/client/components/nameplates.cpp teeworlds-0.5.2-teecomp/src/game/client/components/nameplates.cpp
--- teeworlds-0.5.2-src/src/game/client/components/nameplates.cpp	2009-10-26 19:04:31.000000000 +0100
+++ teeworlds-0.5.2-teecomp/src/game/client/components/nameplates.cpp	2009-10-27 19:06:18.000000000 +0100
@@ -7,6 +7,8 @@
 #include "nameplates.hpp"
 #include "controls.hpp"
 
+#include <game/client/teecomp.hpp>
+
 void NAMEPLATES::render_nameplate(
 	const NETOBJ_CHARACTER *prev_char,
 	const NETOBJ_CHARACTER *player_char,
@@ -25,9 +27,32 @@
 		if(config.cl_nameplates_always == 0)
 			a = clamp(1-powf(distance(gameclient.controls->target_pos, position)/200.0f,16.0f), 0.0f, 1.0f);
 			
-		const char *name = gameclient.clients[player_info->cid].name;
+		char name[256];
+		if(!config.tc_nameplate_score)
+			str_format(name, 256, "%s", gameclient.clients[player_info->cid].name);
+		else
+			str_format(name, 256, "%s (%d)", gameclient.clients[player_info->cid].name, player_info->score);
 		float tw = gfx_text_width(0, 28.0f, name, -1);
-		gfx_text_color(1,1,1,a);
+		if(config.tc_nameplate_shadow)
+		{
+			gfx_text_color(0,0,0,a);
+			gfx_text(0, position.x-tw/2.0f+2, position.y-60+2, 28.0f, name, -1);
+		}
+		bool is_teamplay;
+		is_teamplay = gameclient.snap.gameobj && gameclient.snap.gameobj->flags&GAMEFLAG_TEAMS;
+		if(config.tc_colored_nameplates&1 && is_teamplay)
+		{
+			vec3 col = TeecompUtils::getTeamColor(
+				gameclient.clients[player_info->cid].team,
+				gameclient.snap.local_info->team,
+				config.tc_colored_nameplates_team1,
+				config.tc_colored_nameplates_team2,
+				config.tc_colored_nameplates&2);
+			gfx_text_color(col.r, col.g, col.b, a);
+		}
+		else // FFA or no colored plates
+			gfx_text_color(1,1,1,a);
+
 		gfx_text(0, position.x-tw/2.0f, position.y-60, 28.0f, name, -1);
 		
 		if(config.debug) // render client id when in debug aswell
diff -Nru teeworlds-0.5.2-src/src/game/client/components/scoreboard.cpp teeworlds-0.5.2-teecomp/src/game/client/components/scoreboard.cpp
--- teeworlds-0.5.2-src/src/game/client/components/scoreboard.cpp	2009-10-26 19:04:31.000000000 +0100
+++ teeworlds-0.5.2-teecomp/src/game/client/components/scoreboard.cpp	2009-10-27 19:06:18.000000000 +0100
@@ -6,8 +6,10 @@
 #include <game/client/animstate.hpp>
 #include <game/client/render.hpp>
 #include <game/client/components/motd.hpp>
+#include <game/client/components/teecomp_stats.hpp>
 #include "scoreboard.hpp"
 
+#include <game/client/teecomp.hpp>
 
 SCOREBOARD::SCOREBOARD()
 {
@@ -231,11 +233,20 @@
 			(gameclient.snap.flags[1] && gameclient.snap.flags[1]->carried_by == info->cid))
 		{
 			gfx_blend_normal();
-			gfx_texture_set(data->images[IMAGE_GAME].id);
+			if(config.tc_colored_flags)
+				gfx_texture_set(data->images[IMAGE_GAME_GRAY].id);
+			else
+				gfx_texture_set(data->images[IMAGE_GAME].id);
 			gfx_quads_begin();
 
 			if(info->team == 0) select_sprite(SPRITE_FLAG_BLUE, SPRITE_FLAG_FLIP_X);
 			else select_sprite(SPRITE_FLAG_RED, SPRITE_FLAG_FLIP_X);
+			if(config.tc_colored_flags)
+			{
+				vec3 col = TeecompUtils::getTeamColor(1-info->team, gameclient.snap.local_info->team, 
+					config.tc_colored_tees_team1, config.tc_colored_tees_team2, config.tc_colored_tees_method);
+				gfx_setcolor(col.r, col.g, col.b, 1.0f);
+			}
 			
 			float size = 64.0f;
 			gfx_quads_drawTL(x+55, y-15, size/2, size);
@@ -270,6 +281,10 @@
 	if(gameclient.snap.gameobj && gameclient.snap.gameobj->game_over)
 		do_scoreboard = true;
 		
+	// we're looking at the stats, don't show the scoreboard
+	if(gameclient.teecomp_stats->is_active())
+		do_scoreboard = false;
+
 	if(!do_scoreboard)
 		return;
 		
@@ -293,20 +308,39 @@
 	else
 	{
 			
+		char text[32];
 		if(gameclient.snap.gameobj && gameclient.snap.gameobj->game_over)
 		{
-			const char *text = "DRAW!";
+			str_copy(text, "DRAW!", sizeof(text));
 			if(gameclient.snap.gameobj->teamscore_red > gameclient.snap.gameobj->teamscore_blue)
-				text = "Red Team Wins!";
+			{
+				if(gameclient.snap.local_info->team == 1 && config.tc_colored_tees_method == 1)
+					str_format(text, sizeof(text), "%s Team Wins!", TeecompUtils::rgb_to_name(config.tc_colored_tees_team2));
+				else
+					str_format(text, sizeof(text), "%s Team Wins!", TeecompUtils::rgb_to_name(config.tc_colored_tees_team1));
+			}
 			else if(gameclient.snap.gameobj->teamscore_blue > gameclient.snap.gameobj->teamscore_red)
-				text = "Blue Team Wins!";
+			{
+				if(gameclient.snap.local_info->team == 1 && config.tc_colored_tees_method == 1)
+					str_format(text, sizeof(text), "%s Team Wins!", TeecompUtils::rgb_to_name(config.tc_colored_tees_team1));
+				else
+					str_format(text, sizeof(text), "%s Team Wins!", TeecompUtils::rgb_to_name(config.tc_colored_tees_team2));
+			}
 				
 			float w = gfx_text_width(0, 92.0f, text, -1);
 			gfx_text(0, width/2-w/2, 45, 92.0f, text, -1);
 		}
 		
-		render_scoreboard(width/2-w-20, 150.0f, w, 0, "Red Team");
-		render_scoreboard(width/2 + 20, 150.0f, w, 1, "Blue Team");
+		if(gameclient.snap.local_info && gameclient.snap.local_info->team == 1 && config.tc_colored_tees_method == 1)
+			str_format(text, sizeof(text), "%s Team", TeecompUtils::rgb_to_name(config.tc_colored_tees_team2));
+		else
+			str_format(text, sizeof(text), "%s Team", TeecompUtils::rgb_to_name(config.tc_colored_tees_team1));
+		render_scoreboard(width/2-w-20, 150.0f, w, 0, text);
+		if(gameclient.snap.local_info && gameclient.snap.local_info->team == 1 && config.tc_colored_tees_method == 1)
+			str_format(text, sizeof(text), "%s Team", TeecompUtils::rgb_to_name(config.tc_colored_tees_team1));
+		else
+			str_format(text, sizeof(text), "%s Team", TeecompUtils::rgb_to_name(config.tc_colored_tees_team2));
+		render_scoreboard(width/2 + 20, 150.0f, w, 1, text);
 	}
 
 	render_goals(width/2-w/2, 150+750+25, w);
diff -Nru teeworlds-0.5.2-src/src/game/client/components/teecomp_stats.cpp teeworlds-0.5.2-teecomp/src/game/client/components/teecomp_stats.cpp
--- teeworlds-0.5.2-src/src/game/client/components/teecomp_stats.cpp	1970-01-01 01:00:00.000000000 +0100
+++ teeworlds-0.5.2-teecomp/src/game/client/components/teecomp_stats.cpp	2009-10-27 19:40:12.000000000 +0100
@@ -0,0 +1,531 @@
+#include <engine/e_client_interface.h>
+#include <game/generated/g_protocol.hpp>
+#include <game/generated/gc_data.hpp>
+#include <game/client/gameclient.hpp>
+#include <game/client/animstate.hpp>
+#include <game/client/teecomp.hpp>
+#include "teecomp_stats.hpp"
+
+TEECOMP_STATS::TEECOMP_STATS()
+{
+	on_reset();
+}
+
+void TEECOMP_STATS::on_reset()
+{
+	for(int i=0; i<MAX_CLIENTS; i++)
+		gameclient.stats[i].reset();
+	mode = 0;
+	stats_cid = -1;
+}
+
+void TEECOMP_STATS::con_key_stats(void *result, void *user_data)
+{
+	//((TEECOMP_STATS *)user_data)->active = console_arg_int(result, 0) != 0;
+	if(console_arg_int(result, 0) != 0)
+		((TEECOMP_STATS *)user_data)->mode = console_arg_int(result, 1);
+	else
+		((TEECOMP_STATS *)user_data)->mode = 0;
+}
+
+void TEECOMP_STATS::con_key_next(void *result, void *user_data)
+{
+	//((TEECOMP_STATS *)user_data)->active = console_arg_int(result, 0) != 0;
+	TEECOMP_STATS *stats = (TEECOMP_STATS *)user_data;
+	if(stats->mode != 2)
+		return;
+
+	if(console_arg_int(result, 0) == 0)
+	{
+		stats->stats_cid++;
+		stats->stats_cid %= MAX_CLIENTS;
+		stats->check_stats_cid();
+	}
+}
+
+void TEECOMP_STATS::on_console_init()
+{
+	MACRO_REGISTER_COMMAND("+stats", "i", CFGFLAG_CLIENT, con_key_stats, this, "Show stats");
+	MACRO_REGISTER_COMMAND("+next_stats", "", CFGFLAG_CLIENT, con_key_next, this, "Next player stats");
+}
+
+bool TEECOMP_STATS::is_active() {
+	return (mode > 0);
+}
+
+void TEECOMP_STATS::check_stats_cid()
+{
+	if(stats_cid == -1)
+		stats_cid = gameclient.snap.local_cid;
+
+	int prev = stats_cid;
+	while(!gameclient.stats[stats_cid].active)
+	{
+		stats_cid++;
+		stats_cid %= MAX_CLIENTS;
+		if(stats_cid == prev)
+		{
+			stats_cid = -1;
+			mode = 0;
+			break;
+		}
+	}
+}
+
+void TEECOMP_STATS::on_message(int msgtype, void *rawmsg)
+{
+	if(msgtype == NETMSGTYPE_SV_KILLMSG)
+	{
+		NETMSG_SV_KILLMSG *msg = (NETMSG_SV_KILLMSG *)rawmsg;
+		GAMECLIENT::CLIENT_STATS *stats = gameclient.stats;
+
+		stats[msg->victim].deaths++;
+		if(msg->weapon >= 0)
+			stats[msg->victim].deaths_from[msg->weapon]++;
+		if(msg->mode_special & 1)
+			stats[msg->victim].deaths_carrying++;
+		if(msg->victim != msg->killer)
+		{
+			stats[msg->killer].frags++;
+			if(msg->weapon >= 0)
+				stats[msg->killer].frags_with[msg->weapon]++;
+			if(msg->mode_special & 1)
+				stats[msg->killer].carriers_killed++;
+			if(msg->mode_special & 2)
+				stats[msg->killer].kills_carrying++;
+		}
+		else
+			stats[msg->victim].suicides++;
+	}
+	else if(msgtype == NETMSGTYPE_SV_CHAT)
+	{
+		NETMSG_SV_CHAT *msg = (NETMSG_SV_CHAT *)rawmsg;
+		if(msg->cid < 0)
+		{
+			const char *p;
+			const char *look_for = "flag was captured by ";
+			if(p = str_find_nocase(msg->message, look_for))
+			{
+				char name[64];
+				p += str_length(look_for);
+				str_copy(name, p, sizeof(name));
+				if(str_comp_nocase(name+str_length(name)-9, " seconds)") == 0)
+				{
+					char *c = name+str_length(name)-10;
+					while(c > name)
+					{
+						c--;
+						if(*c == '(')
+						{
+							*(c-1) = 0;
+							break;
+						}
+					}
+				}
+				for(int i=0; i<MAX_CLIENTS; i++)
+				{
+					if(!gameclient.stats[i].active)
+						continue;
+
+					if(str_comp_nocase(gameclient.clients[i].name, name) == 0)
+					{
+						gameclient.stats[i].flag_captures++;
+						break;
+					}
+				}
+			}
+		}
+	}
+}
+
+void TEECOMP_STATS::on_render()
+{
+	switch(mode)
+	{
+		case 1:
+			render_global_stats();
+			break;
+		case 2:
+			render_individual_stats();
+			break;
+	}
+}
+
+void TEECOMP_STATS::render_global_stats()
+{
+	if(mode != 1)
+		return;
+
+	float width = 400*3.0f*gfx_screenaspect();
+	float height = 400*3.0f;
+	float w = 450.0f;
+	float h = 750.0f;
+	
+	const NETOBJ_PLAYER_INFO *players[MAX_CLIENTS] = {0};
+	int num_players = 0;
+	int i;
+	for(i=0; i<snap_num_items(SNAP_CURRENT); i++)
+	{
+		SNAP_ITEM item;
+		const void *data = snap_get_item(SNAP_CURRENT, i, &item);
+
+		if(item.type == NETOBJTYPE_PLAYER_INFO)
+		{
+			const NETOBJ_PLAYER_INFO *info = (const NETOBJ_PLAYER_INFO *)data;
+
+			if(!gameclient.stats[info->cid].active)
+				continue;
+
+			players[num_players] = info;
+			num_players++;
+		}
+	}
+
+	for(int i=0; i<6; i++)
+		if(config.tc_statboard_infos & (1<<i))
+			w += 100;
+	if(gameclient.snap.gameobj && gameclient.snap.gameobj->flags&GAMEFLAG_FLAGS && config.tc_statboard_infos&TC_STATS_FLAGS)
+		w += 100;
+
+	bool display_weapon[NUM_WEAPONS] = {false};
+	if(config.tc_statboard_infos & TC_STATS_WEAPS)
+	{
+		for(i=0; i<num_players; i++)
+		{
+			const GAMECLIENT::CLIENT_STATS stats = gameclient.stats[players[i]->cid];
+			for(int j=0; j<NUM_WEAPONS; j++)
+				display_weapon[j] = display_weapon[j] || stats.frags_with[j] || stats.deaths_from[j];
+		}
+		for(i=0; i<NUM_WEAPONS; i++)
+			if(display_weapon[i])
+				w += 120;
+	}
+
+	float x = width/2-w/2;
+	float y = 200.0f;
+
+	gfx_mapscreen(0, 0, width, height);
+
+	gfx_blend_normal();
+	gfx_texture_set(-1);
+	gfx_quads_begin();
+	gfx_setcolor(0,0,0,0.5f);
+	draw_round_rect(x-10.f, y-10.f, w, h, 17.0f);
+	gfx_quads_end();
+
+	float tw;
+	int px = 525;
+
+	gfx_text(0, x+10, y, 24.0f, "Name", -1);
+	const char *headers[] = { "Frags", "Deaths", "Suicides", "Ratio", "Net", "FPM" };
+	for(i=0; i<6; i++)
+		if(config.tc_statboard_infos & (1<<i))
+		{
+			tw = gfx_text_width(0, 24.0f, headers[i], -1);
+			gfx_text(0, x+px-tw, y, 24.0f, headers[i], -1);
+			px += 100;
+		}
+
+	if(config.tc_statboard_infos & TC_STATS_WEAPS)
+	{
+		gfx_texture_set(data->images[IMAGE_GAME].id);
+		gfx_quads_begin();
+		for(i=0, px-=40; i<NUM_WEAPONS; i++)
+		{
+			if(!display_weapon[i])
+				continue;
+
+			select_sprite(data->weapons.id[i].sprite_body, 0);
+			if(i == 0)
+				draw_sprite(x+px, y+8, data->weapons.id[i].visual_size*0.8);
+			else
+				draw_sprite(x+px, y+8, data->weapons.id[i].visual_size);
+			px += 120;
+		}
+		gfx_quads_end();
+		px += 40;
+	}
+
+	if(gameclient.snap.gameobj && gameclient.snap.gameobj->flags&GAMEFLAG_FLAGS && config.tc_statboard_infos&TC_STATS_FLAGS)
+	{
+		px -= 40;
+		gfx_texture_set(data->images[IMAGE_GAME].id);
+		gfx_quads_begin();
+		gfx_quads_setrotation(0.78f);
+		select_sprite(SPRITE_FLAG_RED);
+		draw_sprite(x+px, y+10, 48);
+		gfx_quads_end();
+	}
+
+	y += 29.0f;
+
+	float font_size = 30.0f;
+	float line_height = 50.0f;
+	float tee_sizemod = 1.0f;
+	float tee_offset = 0.0f;
+	
+	if(num_players > 14)
+	{
+		font_size = 30.0f;
+		line_height = 40.0f;
+		tee_sizemod = 0.8f;
+		tee_offset = -5.0f;
+	}
+
+	for(int j=0; j<num_players; j++)
+	{
+		const NETOBJ_PLAYER_INFO *info = players[j];
+		const GAMECLIENT::CLIENT_STATS stats = gameclient.stats[info->cid];
+
+		if(info->local)
+		{
+			// background so it's easy to find the local player
+			gfx_texture_set(-1);
+			gfx_quads_begin();
+			gfx_setcolor(1,1,1,0.25f);
+			draw_round_rect(x, y, w-20, line_height*0.95f, 17.0f);
+			gfx_quads_end();
+		}
+
+		TEE_RENDER_INFO teeinfo = gameclient.clients[info->cid].render_info;
+		teeinfo.size *= tee_sizemod;
+		render_tee(ANIMSTATE::get_idle(), &teeinfo, EMOTE_NORMAL, vec2(1,0), vec2(x+28, y+28+tee_offset));
+
+		char buf[128];
+		if(config.tc_stat_id)
+		{
+			str_format(buf, sizeof(buf), "%d", info->cid);
+			gfx_text(0, x, y, font_size, buf, -1);
+		}
+
+		gfx_text(0, x+64, y, font_size, gameclient.clients[info->cid].name, -1);
+
+		px = 525;
+
+		if(config.tc_statboard_infos & TC_STATS_FRAGS)
+		{
+			str_format(buf, sizeof(buf), "%d", stats.frags);
+			tw = gfx_text_width(0, font_size, buf, -1);
+			gfx_text(0, x-tw+px, y, font_size, buf, -1);
+			px += 100;
+		}
+		if(config.tc_statboard_infos & TC_STATS_DEATHS)
+		{
+			str_format(buf, sizeof(buf), "%d", stats.deaths);
+			tw = gfx_text_width(0, font_size, buf, -1);
+			gfx_text(0, x-tw+px, y, font_size, buf, -1);
+			px += 100;
+		}
+		if(config.tc_statboard_infos & TC_STATS_SUICIDES)
+		{
+			str_format(buf, sizeof(buf), "%d", stats.suicides);
+			tw = gfx_text_width(0, font_size, buf, -1);
+			gfx_text(0, x-tw+px, y, font_size, buf, -1);
+			px += 100;
+		}
+		if(config.tc_statboard_infos & TC_STATS_RATIO)
+		{
+			if(stats.deaths == 0)
+				str_format(buf, sizeof(buf), "--");
+			else
+				str_format(buf, sizeof(buf), "%.2f", (float)(stats.frags)/stats.deaths);
+			tw = gfx_text_width(0, font_size, buf, -1);
+			gfx_text(0, x-tw+px, y, font_size, buf, -1);
+			px += 100;
+		}
+		if(config.tc_statboard_infos & TC_STATS_NET)
+		{
+			str_format(buf, sizeof(buf), "%+d", stats.frags-stats.deaths);
+			tw = gfx_text_width(0, font_size, buf, -1);
+			gfx_text(0, x-tw+px, y, font_size, buf, -1);
+			px += 100;
+		}
+		if(config.tc_statboard_infos & TC_STATS_FPM)
+		{
+			float fpm = (float)(stats.frags*60)/((float)(client_tick()-stats.join_date)/client_tickspeed());
+			str_format(buf, sizeof(buf), "%.1f", fpm);
+			tw = gfx_text_width(0, font_size, buf, -1);
+			gfx_text(0, x-tw+px, y, font_size, buf, -1);
+			px += 100;
+		}
+		for(i=0, px=px-40; i<NUM_WEAPONS; i++)
+		{
+			if(!display_weapon[i])
+				continue;
+
+			str_format(buf, sizeof(buf), "%d/%d", stats.frags_with[i], stats.deaths_from[i]);
+			tw = gfx_text_width(0, font_size, buf, -1);
+			gfx_text(0, x+px-tw/2, y, font_size, buf, -1);
+			px += 120;
+		}
+		if(gameclient.snap.gameobj && gameclient.snap.gameobj->flags&GAMEFLAG_FLAGS && config.tc_statboard_infos&TC_STATS_FLAGS)
+		{
+			str_format(buf, sizeof(buf), "%d", stats.flag_captures);
+			tw = gfx_text_width(0, font_size, buf, -1);
+			gfx_text(0, x-tw+px, y, font_size, buf, -1);
+			px += 100;
+		}
+		y += line_height;
+	}
+}
+
+void TEECOMP_STATS::render_individual_stats()
+{
+	if(mode != 2)
+		return;
+	check_stats_cid();
+	if(mode != 2)
+		return;
+	int cid = stats_cid;
+	float width = 400*3.0f*gfx_screenaspect();
+	float height = 400*3.0f;
+	float w = 1200.0f;
+	float x = width/2-w/2;
+	float y = 100.0f;
+	float xo = 200.0f;
+	float font_size = 30.0f;
+	float line_height = 40.0f;
+	const GAMECLIENT::CLIENT_STATS stats = gameclient.stats[cid];
+
+	gfx_mapscreen(0, 0, width, height);
+
+	// header with name and score
+	gfx_blend_normal();
+	gfx_texture_set(-1);
+	gfx_quads_begin();
+	gfx_setcolor(0,0,0,0.5f);
+	draw_round_rect(x-10.f, y-10.f, w, 120.0f, 17.0f);
+	gfx_quads_end();
+
+	TEE_RENDER_INFO teeinfo = gameclient.clients[cid].render_info;
+	teeinfo.size *= 1.5f;
+	render_tee(ANIMSTATE::get_idle(), &teeinfo, EMOTE_NORMAL, vec2(1,0), vec2(x+xo+32, y+36));
+	gfx_text(0, x+xo+128, y, 48.0f, gameclient.clients[cid].name, -1);
+
+	char buf[64];
+	if(config.tc_stat_id)
+	{
+		str_format(buf, sizeof(buf), "%d", cid);
+		gfx_text(0, x+xo, y, font_size, buf, -1);
+	}
+
+	str_format(buf, sizeof(buf), "Score: %d", gameclient.snap.player_infos[cid]->score);
+	gfx_text(0, x+xo, y+64, font_size, buf, -1);
+	int seconds = (float)(client_tick()-stats.join_date)/client_tickspeed();
+	str_format(buf, sizeof(buf), "Time played: %02d:%02d", seconds/60, seconds%60);
+	gfx_text(0, x+xo+256, y+64, font_size, buf, -1);
+
+	y += 150.0f;
+
+	// Frags, etc. stats
+	gfx_blend_normal();
+	gfx_texture_set(-1);
+	gfx_quads_begin();
+	gfx_setcolor(0,0,0,0.5f);
+	draw_round_rect(x-10.f, y-10.f, w, 100.0f, 17.0f);
+	gfx_quads_end();
+
+	gfx_texture_set(data->images[IMAGE_EMOTICONS].id);
+	gfx_quads_begin();
+	gfx_setcolor(1.0f,1.0f,1.0f,1.0f);
+	select_sprite(SPRITE_DEADTEE);
+	gfx_quads_draw(x+xo/2, y+40, 128, 128);
+	gfx_quads_end();
+
+	str_format(buf, sizeof(buf), "Frags: %d", stats.frags);
+	gfx_text(0, x+xo, y, font_size, buf, -1);
+	str_format(buf, sizeof(buf), "Deaths: %d", stats.deaths);
+	gfx_text(0, x+xo+200.0f, y, font_size, buf, -1);
+	str_format(buf, sizeof(buf), "Suicides: %d", stats.suicides);
+	gfx_text(0, x+xo+400.0f, y, font_size, buf, -1);
+	y += line_height;
+
+	if(stats.deaths == 0)
+		str_format(buf, sizeof(buf), "Ratio: --");
+	else
+		str_format(buf, sizeof(buf), "Ratio: %.2f", (float)(stats.frags)/stats.deaths);
+	gfx_text(0, x+xo, y, font_size, buf, -1);
+	str_format(buf, sizeof(buf), "Net: %d", stats.frags-stats.deaths);
+	gfx_text(0, x+xo+200.0f, y, font_size, buf, -1);
+	float fpm = (float)(stats.frags*60)/((float)(client_tick()-stats.join_date)/client_tickspeed());
+	str_format(buf, sizeof(buf), "FPM: %.1f", fpm);
+	gfx_text(0, x+xo+400.0f, y, font_size, buf, -1);
+	y+= line_height + 30.0f;
+
+	// Weapon stats
+	bool display_weapon[NUM_WEAPONS] = {false};
+	int num_weaps = 0;
+	for(int i=0; i<NUM_WEAPONS; i++)
+		if(stats.frags_with[i] || stats.deaths_from[i])
+		{
+			display_weapon[i] = true;
+			num_weaps++;
+		}
+
+	if(num_weaps)
+	{
+		gfx_blend_normal();
+		gfx_texture_set(-1);
+		gfx_quads_begin();
+		gfx_setcolor(0,0,0,0.5f);
+		draw_round_rect(x-10.f, y-10.f, w, line_height*(1+num_weaps)+20.0f, 17.0f);
+		gfx_quads_end();
+
+		gfx_text(0, x+xo, y, font_size, "Frags", -1);
+		gfx_text(0, x+xo+200.0f, y, font_size, "Deaths", -1);
+		y += line_height;
+
+		for(int i=0; i<NUM_WEAPONS; i++)
+		{
+			if(!display_weapon[i])
+				continue;
+
+			gfx_texture_set(data->images[IMAGE_GAME].id);
+			gfx_quads_begin();
+			select_sprite(data->weapons.id[i].sprite_body, 0);
+			draw_sprite(x+xo/2, y+24, data->weapons.id[i].visual_size);
+			gfx_quads_end();
+
+			str_format(buf, sizeof(buf), "%d", stats.frags_with[i]);
+			gfx_text(0, x+xo, y, font_size, buf, -1);
+			str_format(buf, sizeof(buf), "%d", stats.deaths_from[i]);
+			gfx_text(0, x+xo+200.0f, y, font_size, buf, -1);
+			y += line_height;
+		}
+		y += 30.0f;
+	}
+
+	// Flag stats
+	if(gameclient.snap.gameobj && gameclient.snap.gameobj->flags&GAMEFLAG_FLAGS)
+	{
+		gfx_blend_normal();
+		gfx_texture_set(-1);
+		gfx_quads_begin();
+		gfx_setcolor(0,0,0,0.5f);
+		draw_round_rect(x-10.f, y-10.f, w, line_height*5+20.0f, 17.0f);
+		gfx_quads_end();
+
+		gfx_texture_set(data->images[IMAGE_GAME].id);
+		gfx_quads_begin();
+		select_sprite(SPRITE_FLAG_RED);
+		draw_sprite(x+xo/2, y+100.0f, 192);
+		gfx_quads_end();
+
+		str_format(buf, sizeof(buf), "Grabs: %d", stats.flag_grabs);
+		gfx_text(0, x+xo, y, font_size, buf, -1);
+		y += line_height;
+		str_format(buf, sizeof(buf), "Captures: %d", stats.flag_captures);
+		gfx_text(0, x+xo, y, font_size, buf, -1);
+		y += line_height;
+		str_format(buf, sizeof(buf), "Kills holding flag: %d", stats.kills_carrying);
+		gfx_text(0, x+xo, y, font_size, buf, -1);
+		y += line_height;
+		str_format(buf, sizeof(buf), "Deaths with flag: %d", stats.deaths_carrying);
+		gfx_text(0, x+xo, y, font_size, buf, -1);
+		y += line_height;
+		str_format(buf, sizeof(buf), "Carriers killed: %d", stats.carriers_killed);
+		gfx_text(0, x+xo, y, font_size, buf, -1);
+		y += line_height;
+	}
+}
+
diff -Nru teeworlds-0.5.2-src/src/game/client/components/teecomp_stats.hpp teeworlds-0.5.2-teecomp/src/game/client/components/teecomp_stats.hpp
--- teeworlds-0.5.2-src/src/game/client/components/teecomp_stats.hpp	1970-01-01 01:00:00.000000000 +0100
+++ teeworlds-0.5.2-teecomp/src/game/client/components/teecomp_stats.hpp	2009-10-27 19:06:18.000000000 +0100
@@ -0,0 +1,22 @@
+#include <game/client/component.hpp>
+
+class TEECOMP_STATS: public COMPONENT
+{
+private:
+	int mode;
+	int stats_cid;
+	static void con_key_stats(void *result, void *user_data);
+	static void con_key_next(void *result, void *user_data);
+	void render_global_stats();
+	void render_individual_stats();
+	void check_stats_cid();
+
+public:
+	TEECOMP_STATS();
+	virtual void on_reset();
+	virtual void on_console_init();
+	virtual void on_render();
+	virtual void on_message(int msgtype, void *rawmsg);
+	bool is_active();
+};
+
diff -Nru teeworlds-0.5.2-src/src/game/client/gameclient.cpp teeworlds-0.5.2-teecomp/src/game/client/gameclient.cpp
--- teeworlds-0.5.2-src/src/game/client/gameclient.cpp	2009-10-26 19:04:31.000000000 +0100
+++ teeworlds-0.5.2-teecomp/src/game/client/gameclient.cpp	2009-10-27 19:06:18.000000000 +0100
@@ -35,6 +35,9 @@
 #include "components/skins.hpp"
 #include "components/sounds.hpp"
 #include "components/voting.hpp"
+#include "components/teecomp_stats.hpp"
+
+#include <game/client/teecomp.hpp>
 
 GAMECLIENT gameclient;
 
@@ -59,6 +62,7 @@
 static EMOTICON emoticon;
 static DAMAGEIND damageind;
 static VOTING voting;
+static TEECOMP_STATS teecomp_stats;
 
 static PLAYERS players;
 static NAMEPLATES nameplates;
@@ -115,6 +119,7 @@
 	damageind = &::damageind;
 	mapimages = &::mapimages;
 	voting = &::voting;
+	teecomp_stats = &::teecomp_stats;
 	
 	// make a list of all the systems, make sure to add them in the corrent render order
 	all.add(skins);
@@ -144,6 +149,7 @@
 	all.add(&broadcast);
 	all.add(&debughud);
 	all.add(&scoreboard);
+	all.add(teecomp_stats);
 	all.add(motd);
 	all.add(menus);
 	all.add(console);
@@ -233,6 +239,75 @@
 	dbg_msg("", "%f.2ms", ((end-start)*1000)/(float)time_freq());
 	
 	servermode = SERVERMODE_PURE;
+
+	// Teecomp grayscale flags
+	gfx_unload_texture(data->images[IMAGE_GAME_GRAY].id); // Already loaded with full color, unload
+	data->images[IMAGE_GAME_GRAY].id = -1;
+
+	IMAGE_INFO info;
+	if(!gfx_load_png(&info, data->images[IMAGE_GAME_GRAY].filename))
+		return;
+
+	unsigned char *d = (unsigned char *)info.data;
+	int step = info.format == IMG_RGBA ? 4 : 3;
+
+	for(int i=0; i < info.width*info.height; i++)
+	{
+		int v = (d[i*step]+d[i*step+1]+d[i*step+2])/3;
+		d[i*step] = v;
+		d[i*step+1] = v;
+		d[i*step+2] = v;
+	}
+
+	int freq[256];
+	int org_weight;
+	int new_weight;
+	int flag_x = 384;
+	int flag_y = 256;
+	int flag_w = 128;
+	int flag_h = 256;
+	int pitch = info.width*4;
+
+	for(int f=0; f<2; f++)
+	{
+		org_weight = 0;
+		new_weight = 192;
+		for(int i=0; i<256; i++)
+			freq[i] = 0;
+
+		// find most common frequence
+		for(int y=flag_y; y<flag_y+flag_h; y++)
+			for(int x=flag_x+flag_w*f; x<flag_x+flag_w*(1+f); x++)
+			{
+				if(d[y*pitch+x*4+3] > 128)
+					freq[d[y*pitch+x*4]]++;
+			}
+		
+		for(int i = 1; i < 256; i++)
+		{
+			if(freq[org_weight] < freq[i])
+				org_weight = i;
+		}
+
+		// reorder
+		int inv_org_weight = 255-org_weight;
+		int inv_new_weight = 255-new_weight;
+		for(int y=flag_y; y<flag_y+flag_h; y++)
+			for(int x=flag_x+flag_w*f; x<flag_x+flag_w*(1+f); x++)
+			{
+				int v = d[y*pitch+x*4];
+				if(v <= org_weight*1.25f) // modified for contrast
+					v = (int)(((v/(float)org_weight) * new_weight));
+				else
+					v = (int)(((v-org_weight)/(float)inv_org_weight)*inv_new_weight + new_weight);
+				d[y*pitch+x*4] = v;
+				d[y*pitch+x*4+1] = v;
+				d[y*pitch+x*4+2] = v;
+			}
+	}
+
+	data->images[IMAGE_GAME_GRAY].id = gfx_load_texture_raw(info.width, info.height, info.format, info.data, info.format, 0);
+	mem_free(info.data);
 }
 
 void GAMECLIENT::on_save()
@@ -246,7 +321,7 @@
 	// handle mouse movement
 	int x=0, y=0;
 	inp_mouse_relative(&x, &y);
-	if(x || y)
+	if(x || y || !freeview)
 	{
 		for(int h = 0; h < input.num; h++)
 		{
@@ -277,7 +352,31 @@
 
 int GAMECLIENT::on_snapinput(int *data)
 {
-	return controls->snapinput(data);
+	int val = controls->snapinput(data);
+	if(val && snap.spectate)
+	{
+		NETOBJ_PLAYER_INPUT *inp = (NETOBJ_PLAYER_INPUT *)data;
+		static bool last_fire = false, last_hook = false;
+
+		if(inp->fire&1 && !last_fire)
+		{
+			find_next_spectable_cid();
+			last_fire = true;
+		}
+		else if(!(inp->fire&1) && last_fire)
+			last_fire = false;
+
+		if(inp->hook && !last_hook)
+		{
+			freeview = !freeview;
+			if(!freeview)
+				find_next_spectable_cid();
+			last_hook = true;
+		}
+		else if(!inp->hook && last_hook)
+			last_hook = false;
+	}
+	return val;
 }
 
 void GAMECLIENT::on_connected()
@@ -299,6 +398,13 @@
 	
 	// send the inital info
 	send_info(true);
+
+	freeview = true;
+	spectate_cid = -1;
+	last_game_over = false;
+	last_warmup = false;
+	last_flag_carrier[0] = -1;
+	last_flag_carrier[1] = -1;
 }
 
 void GAMECLIENT::on_reset()
@@ -318,7 +424,9 @@
 		clients[i].skin_info.texture = gameclient.skins->get(0)->color_texture;
 		clients[i].skin_info.color_body = vec4(1,1,1,1);
 		clients[i].skin_info.color_feet = vec4(1,1,1,1);
-		clients[i].update_render_info();
+		clients[i].update_render_info(i);
+
+		stats[i].reset();
 	}
 	
 	for(int i = 0; i < all.num; i++)
@@ -343,8 +451,41 @@
 			vec2(snap.local_prev_character->x, snap.local_prev_character->y),
 			vec2(snap.local_character->x, snap.local_character->y), client_intratick());
 	}
+	if(spectate_cid == -1)
+		freeview = true;
+	if(snap.spectate && !freeview)
+	{
+		if(!snap.characters[spectate_cid].active || clients[spectate_cid].team == -1)
+		{
+			freeview = true;
+			return;
+		}
+		spectate_pos = mix(
+			vec2(snap.characters[spectate_cid].prev.x, snap.characters[spectate_cid].prev.y),
+			vec2(snap.characters[spectate_cid].cur.x, snap.characters[spectate_cid].cur.y), client_intratick());
+	}
 }
 
+void GAMECLIENT::find_next_spectable_cid()
+{
+	int next = spectate_cid+1;
+	next %= MAX_CLIENTS;
+	int prev = next;
+	while(!snap.characters[next].active || clients[next].team == -1)
+	{
+		next++;
+		next %= MAX_CLIENTS;
+		if(next == prev)
+		{
+			freeview = true;
+			spectate_cid = -1;
+			return;
+		}
+	}
+	spectate_cid = next;
+	if(freeview)
+		freeview = false;
+}
 
 static void evolve(NETOBJ_CHARACTER *character, int tick)
 {
@@ -473,6 +614,9 @@
 	// then change the state
 	for(int i = 0; i < all.num; i++)
 		all.components[i]->on_statechange(new_state, old_state);
+
+	if(new_state == CLIENTSTATE_ONLINE && config.tc_autodemo)
+		teecomp_demo_start();
 }
 
 
@@ -570,6 +714,10 @@
 	{
 		snap.team_size[0] = snap.team_size[1] = 0;
 		
+		// TeeComp.
+		for(int i=0; i<MAX_CLIENTS; i++)
+			stats[i].active = false;
+
 		int num = snap_num_items(SNAP_CURRENT);
 		for(int i = 0; i < num; i++)
 		{
@@ -613,9 +761,8 @@
 					clients[cid].skin_info.color_feet = vec4(1,1,1,1);
 				}
 
-				clients[cid].update_render_info();
+				clients[cid].update_render_info(cid);
 				gameclient.snap.num_players++;
-				
 			}
 			else if(item.type == NETOBJTYPE_PLAYER_INFO)
 			{
@@ -635,7 +782,10 @@
 				
 				// calculate team-balance
 				if(info->team != -1)
+				{
 					snap.team_size[info->team]++;
+					stats[info->cid].active = true;
+				}
 				
 			}
 			else if(item.type == NETOBJTYPE_CHARACTER)
@@ -654,9 +804,46 @@
 				}
 			}
 			else if(item.type == NETOBJTYPE_GAME)
+			{
 				snap.gameobj = (NETOBJ_GAME *)data;
+				if(snap.gameobj->game_over != last_game_over)
+				{
+					if(!last_game_over)
+						on_game_over();
+					else
+						on_game_restart();
+					last_game_over = snap.gameobj->game_over;
+				}
+				if((snap.gameobj->warmup > 0) != last_warmup)
+				{
+					if(last_warmup)
+						on_warmup_end();
+					last_warmup = snap.gameobj->warmup > 0;
+				}
+			}
 			else if(item.type == NETOBJTYPE_FLAG)
-				snap.flags[item.id%2] = (const NETOBJ_FLAG *)data;
+			{
+				int fid = item.id%2;
+				snap.flags[fid] = (const NETOBJ_FLAG *)data;
+				if(snap.flags[fid]->carried_by != last_flag_carrier[fid])
+				{
+					if(snap.flags[fid]->carried_by >= 0)
+						on_flag_grab(fid);
+					last_flag_carrier[fid] = snap.flags[fid]->carried_by;
+				}
+			}
+		}
+
+		// TeeComp
+		for(int i=0; i<MAX_CLIENTS; i++)
+		{
+			if(stats[i].active && !stats[i].was_active)
+			{
+				stats[i].reset(); // Client connected, reset stats.
+				stats[i].active = true;
+				stats[i].join_date = client_tick();
+			}
+			stats[i].was_active = stats[i].active;
 		}
 	}
 	
@@ -690,7 +877,7 @@
 
 	// update render info
 	for(int i = 0; i < MAX_CLIENTS; i++)
-		clients[i].update_render_info();
+		clients[i].update_render_info(i);
 }
 
 void GAMECLIENT::on_predict()
@@ -817,21 +1004,105 @@
 	predicted_tick = client_predtick();
 }
 
-void GAMECLIENT::CLIENT_DATA::update_render_info()
+void GAMECLIENT::on_game_over()
+{
+	if(config.tc_autoscreen && !demorec_isplaying())
+		gfx_screenshot();
+}
+
+void GAMECLIENT::on_game_restart()
+{
+	if(!demorec_isplaying() && config.tc_autodemo && demorec_isrecording())
+	{
+		demorec_record_stop();
+		teecomp_demo_start();
+	}
+	for(int i=0; i<MAX_CLIENTS; i++)
+		stats[i].reset();
+}
+
+void GAMECLIENT::on_warmup_end()
+{
+	for(int i=0; i<MAX_CLIENTS; i++)
+		stats[i].reset();
+}
+
+void GAMECLIENT::on_flag_grab(int id)
+{
+	stats[snap.flags[id]->carried_by].flag_grabs++;
+}
+
+void GAMECLIENT::CLIENT_STATS::reset()
+{
+	join_date  = 0;
+	active     = false;
+	was_active = false;
+	frags      = 0;
+	deaths     = 0;
+	suicides   = 0;
+	for(int j=0; j<NUM_WEAPONS; j++)
+	{
+		frags_with[j]  = 0;
+		deaths_from[j] = 0;
+	}
+	flag_grabs      = 0;
+	flag_captures   = 0;
+	carriers_killed = 0;
+	kills_carrying  = 0;
+	deaths_carrying = 0;
+}
+
+void GAMECLIENT::CLIENT_DATA::update_render_info(int cid)
 {
 	render_info = skin_info;
 
 	// force team colors
 	if(gameclient.snap.gameobj && gameclient.snap.gameobj->flags&GAMEFLAG_TEAMS)
 	{
-		const int team_colors[2] = {65387, 10223467};
-		if(team >= 0 || team <= 1)
+		int local_team;
+		if(gameclient.snap.local_info)
+			local_team = gameclient.snap.local_info->team;
+		else // local_info null when joining a server
+			local_team = 0;
+
+		if(team != -1)
+		{
+			const char* forced_skin;
+			int sid = skin_id;
+			if(cid != gameclient.snap.local_cid && TeecompUtils::get_forced_skin_name(team, local_team, forced_skin))
+				sid = max(0, gameclient.skins->find(forced_skin));
+
+			if(TeecompUtils::get_force_dm_colors(team, local_team))
+			{
+				render_info.texture = gameclient.skins->get(sid)->org_texture;
+				render_info.color_body = vec4(1,1,1,1);
+				render_info.color_feet = vec4(1,1,1,1);
+			}
+			else
+			{
+				render_info.texture = gameclient.skins->get(sid)->color_texture;
+				vec3 col = TeecompUtils::getTeamColor(team, local_team, config.tc_colored_tees_team1,
+					config.tc_colored_tees_team2, config.tc_colored_tees_method);
+				render_info.color_body = vec4(col.r, col.g, col.b, 1.0f);
+				render_info.color_feet = vec4(col.r, col.g, col.b, 1.0f);
+			}
+		}
+		else
 		{
 			render_info.texture = gameclient.skins->get(skin_id)->color_texture;
-			render_info.color_body = gameclient.skins->get_color(team_colors[team]);
-			render_info.color_feet = gameclient.skins->get_color(team_colors[team]);
+			render_info.color_body = vec4(1,1,1,1);
+			render_info.color_feet = vec4(1,1,1,1);
 		}
 	}		
+	else if(config.tc_force_skin_team1 && cid != gameclient.snap.local_cid) // Force DM skin
+	{
+		const SKINS::SKIN* skin;
+		skin = gameclient.skins->get(max(0, gameclient.skins->find(config.tc_forced_skin1)));
+		if(use_custom_color)
+			render_info.texture = skin->color_texture;
+		else
+			render_info.texture = skin->org_texture;
+	}
 }
 
 void GAMECLIENT::send_switch_team(int team)
diff -Nru teeworlds-0.5.2-src/src/game/client/gameclient.hpp teeworlds-0.5.2-teecomp/src/game/client/gameclient.hpp
--- teeworlds-0.5.2-src/src/game/client/gameclient.hpp	2009-10-26 19:04:31.000000000 +0100
+++ teeworlds-0.5.2-teecomp/src/game/client/gameclient.hpp	2009-10-27 19:06:18.000000000 +0100
@@ -112,11 +112,37 @@
 		
 		float angle;
 		
-		void update_render_info();
+		void update_render_info(int cid);
 	};
 
 	CLIENT_DATA clients[MAX_CLIENTS];
 	
+	// TeeComp vars
+	struct CLIENT_STATS
+	{
+		int join_date;
+		bool active;
+		bool was_active;
+
+		int frags_with[NUM_WEAPONS];
+		int deaths_from[NUM_WEAPONS];
+		int frags;
+		int deaths;
+		int suicides;
+
+		int flag_grabs;
+		int flag_captures;
+		int carriers_killed;
+		int kills_carrying;
+		int deaths_carrying;
+
+		void reset();
+	};
+	CLIENT_STATS stats[MAX_CLIENTS];
+	bool freeview;
+	int spectate_cid;
+	vec2 spectate_pos;
+
 	void on_reset();
 
 	// hooks
@@ -131,6 +157,16 @@
 	void on_predict();
 	int on_snapinput(int *data);
 
+	// TeeComp hooks
+	bool last_game_over;
+	bool last_warmup;
+	int last_flag_carrier[2];
+	void on_game_over();
+	void on_game_restart();
+	void on_warmup_end();
+	void on_flag_grab(int id);
+	void find_next_spectable_cid();
+
 	// actions
 	// TODO: move these
 	void send_switch_team(int team);
@@ -153,6 +189,7 @@
 	class MOTD *motd;
 	class MAPIMAGES *mapimages;
 	class VOTING *voting;
+	class TEECOMP_STATS *teecomp_stats;
 };
 
 extern GAMECLIENT gameclient;
diff -Nru teeworlds-0.5.2-src/src/game/client/teecomp.cpp teeworlds-0.5.2-teecomp/src/game/client/teecomp.cpp
--- teeworlds-0.5.2-src/src/game/client/teecomp.cpp	1970-01-01 01:00:00.000000000 +0100
+++ teeworlds-0.5.2-teecomp/src/game/client/teecomp.cpp	2009-10-27 19:06:18.000000000 +0100
@@ -0,0 +1,143 @@
+#include "teecomp.hpp"
+#include <engine/e_config.h>
+#include <base/math.hpp>
+#include <base/system.h>
+
+vec3 TeecompUtils::getTeamColor(int for_team, int local_team, int color1, int color2, int method)
+{
+	vec3 c1((color1>>16)/255.0f, ((color1>>8)&0xff)/255.0f, (color1&0xff)/255.0f);
+	vec3 c2((color2>>16)/255.0f, ((color2>>8)&0xff)/255.0f, (color2&0xff)/255.0f);
+
+	// Team based colors or spectating
+	if(!method || local_team == -1)
+	{
+		if(for_team == 0)
+			return c1;
+		return c2;
+	}
+
+	// Enemy based colors
+	if(for_team == local_team)
+		return c1;
+	return c2;
+}
+
+bool TeecompUtils::get_forced_skin_name(int for_team, int local_team, const char*& skin_name)
+{
+	// Team based colors or spectating
+	if(!config.tc_forced_skins_method || local_team == -1)
+	{
+		if(for_team == 0)
+		{
+			skin_name = config.tc_forced_skin1;
+			return config.tc_force_skin_team1;
+		}
+		skin_name = config.tc_forced_skin2;
+		return config.tc_force_skin_team2;
+	}
+
+	// Enemy based colors
+	if(for_team == local_team)
+	{
+		skin_name = config.tc_forced_skin1;
+		return config.tc_force_skin_team1;
+	}
+	skin_name = config.tc_forced_skin2;
+	return config.tc_force_skin_team2;
+}
+
+bool TeecompUtils::get_force_dm_colors(int for_team, int local_team)
+{
+	if(!config.tc_colored_tees_method || local_team == -1)
+	{
+		if(for_team == 0)
+			return config.tc_dm_colors_team1;
+		return config.tc_dm_colors_team2;
+	}
+
+	if(for_team == local_team)
+		return config.tc_dm_colors_team1;
+	return config.tc_dm_colors_team2;
+}
+
+void TeecompUtils::reset_config()
+{
+	#define MACRO_CONFIG_INT(name, def, min, max, flags, desc) config.name = def;
+	#define MACRO_CONFIG_STR(name, len, def, flags, desc) str_copy(config.name, def, len);
+	#include "../teecomp_vars.hpp"
+	#undef MACRO_CONFIG_INT
+	#undef MACRO_CONFIG_STR
+}
+
+static vec3 rgb_to_hsl(vec3 rgb)
+{
+	float r = rgb.r;
+	float g = rgb.g;
+	float b = rgb.b;
+
+	float vMin = min(min(r, g), b);
+	float vMax = max(max(r, g), b);
+	float dMax = vMax - vMin;
+
+	float h;
+	float s;
+	float l = (vMax + vMin) / 2.0f;
+
+	if(dMax == 0.0f)
+	{
+		h = 0.0f;
+		s = 0.0f;
+	}
+	else
+	{
+		if(l < 0.5f)
+			s = dMax / (vMax + vMin);
+		else
+			s = dMax / (2 - vMax - vMin);
+
+		float dR = (((vMax - r) / 6.0f) + (dMax / 2.0f)) / dMax;
+		float dG = (((vMax - g) / 6.0f) + (dMax / 2.0f)) / dMax;
+		float dB = (((vMax - b) / 6.0f) + (dMax / 2.0f)) / dMax;
+
+		if(r == vMax)
+			h = dB - dG;
+		else if(g == vMax)
+			h = (1.0f/3.0f) + dR - dB;
+		else if(b == vMax)
+			h = (2.0f/3.0f) + dG - dR;
+
+		if(h < 0.0f)
+			h += 1.0f;
+		if(h > 1.0f)
+			h -= 1.0f;
+	}
+
+	return vec3(h*360, s, l);
+}
+
+const char* TeecompUtils::rgb_to_name(int rgb)
+{
+	vec3 rgb_v((rgb>>16)/255.0f, ((rgb>>8)&0xff)/255.0f, (rgb&0xff)/255.0f);
+	vec3 hsl = rgb_to_hsl(rgb_v);
+
+	if(hsl.l < 0.2f)
+		return "Black";
+	if(hsl.l > 0.9f)
+		return "White";
+	if(hsl.s < 0.1f)
+		return "Gray";
+	if(hsl.h < 20)
+		return "Red";
+	if(hsl.h < 45)
+		return "Orange";
+	if(hsl.h < 70)
+		return "Yellow";
+	if(hsl.h < 155)
+		return "Green";
+	if(hsl.h < 260)
+		return "Blue";
+	if(hsl.h < 335)
+		return "Purple";
+	return "Red";
+}
+
diff -Nru teeworlds-0.5.2-src/src/game/client/teecomp.hpp teeworlds-0.5.2-teecomp/src/game/client/teecomp.hpp
--- teeworlds-0.5.2-src/src/game/client/teecomp.hpp	1970-01-01 01:00:00.000000000 +0100
+++ teeworlds-0.5.2-teecomp/src/game/client/teecomp.hpp	2009-10-27 19:06:18.000000000 +0100
@@ -0,0 +1,28 @@
+#ifndef __TEECOMP_HPP_
+#define __TEECOMP_HPP_
+
+#include <base/vmath.hpp>
+
+enum {
+	TC_STATS_FRAGS=1,
+	TC_STATS_DEATHS=2,
+	TC_STATS_SUICIDES=4,
+	TC_STATS_RATIO=8,
+	TC_STATS_NET=16,
+	TC_STATS_FPM=32,
+	TC_STATS_WEAPS=64,
+	TC_STATS_FLAGS=128
+};
+
+class TeecompUtils
+{
+public:
+	static vec3 getTeamColor(int for_team, int local_team, int color1, int color2, int method);
+	static bool get_forced_skin_name(int for_team, int local_team, const char*& skin_name);
+	static bool get_force_dm_colors(int for_team, int local_team);
+	static void reset_config();
+	static const char* rgb_to_name(int rgb);
+};
+
+#endif
+
diff -Nru teeworlds-0.5.2-src/src/game/teecomp_vars.hpp teeworlds-0.5.2-teecomp/src/game/teecomp_vars.hpp
--- teeworlds-0.5.2-src/src/game/teecomp_vars.hpp	1970-01-01 01:00:00.000000000 +0100
+++ teeworlds-0.5.2-teecomp/src/game/teecomp_vars.hpp	2009-10-27 19:06:18.000000000 +0100
@@ -0,0 +1,33 @@
+MACRO_CONFIG_INT(tc_nameplate_shadow, 0, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Enable name plate shadow")
+MACRO_CONFIG_INT(tc_nameplate_score, 0, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Display score on name plates")
+MACRO_CONFIG_INT(tc_colored_nameplates, 0, 0, 3, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Enable colored name plates")
+MACRO_CONFIG_INT(tc_colored_nameplates_team1, 16739179, 0, 16777215, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Red team/team mates name plate color")
+MACRO_CONFIG_INT(tc_colored_nameplates_team2, 7053311, 0, 16777215, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Blue team/enemies name plate color")
+
+MACRO_CONFIG_INT(tc_colored_tees_method, 0, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Enable enemy based skin colors")
+MACRO_CONFIG_INT(tc_dm_colors_team1, 0, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Use DM colors for red team/team mates")
+MACRO_CONFIG_INT(tc_dm_colors_team2, 0, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Use DM colors for blue team/enemies")
+MACRO_CONFIG_INT(tc_colored_tees_team1, 16739179, 0, 16777215, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Red team/team mates color")
+MACRO_CONFIG_INT(tc_colored_tees_team2, 7053311, 0, 16777215, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Blue team/enemies color")
+
+MACRO_CONFIG_INT(tc_forced_skins_method, 0, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Enable enemy based forced skins")
+MACRO_CONFIG_INT(tc_force_skin_team1, 0, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Force a skin for red team/your team/DM matchs")
+MACRO_CONFIG_INT(tc_force_skin_team2, 0, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Force a skin for blue team/opponents")
+MACRO_CONFIG_STR(tc_forced_skin1, 64, "default", CFGFLAG_CLIENT|CFGFLAG_SAVE, "Forced skin for red/mates/DM matchs")
+MACRO_CONFIG_STR(tc_forced_skin2, 64, "default", CFGFLAG_CLIENT|CFGFLAG_SAVE, "Forced skin for blue/opponents")
+
+MACRO_CONFIG_INT(tc_hud_match, 0, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Make HUD match tees' colors")
+MACRO_CONFIG_INT(tc_speedmeter, 0, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Display speed meter")
+MACRO_CONFIG_INT(tc_speedmeter_accel, 0, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Speed meter shows acceleration")
+
+MACRO_CONFIG_INT(tc_autodemo, 0, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Enable auto demo recording")
+MACRO_CONFIG_INT(tc_autoscreen, 0, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Enable auto screenshot")
+
+MACRO_CONFIG_INT(tc_colored_flags, 0, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Make flags colors match tees colors")
+MACRO_CONFIG_INT(tc_hide_carrying, 0, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Hide the flag if you're carrying it")
+
+MACRO_CONFIG_INT(tc_statboard_infos, 235, 1, 255, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Mask of infos to display on the global statboard")
+MACRO_CONFIG_INT(tc_stat_id, 0, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Show player id in statboards")
+MACRO_CONFIG_INT(tc_disable_chat, 0, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Disable chat")
+MACRO_CONFIG_INT(tc_laser_color_inner, 8355839, 0, 16777215, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Inner color of laser")
+MACRO_CONFIG_INT(tc_laser_color_outer, 1250112, 0, 16777215, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Outer color of laser")
diff -Nru teeworlds-0.5.2-src/src/game/variables.hpp teeworlds-0.5.2-teecomp/src/game/variables.hpp
--- teeworlds-0.5.2-src/src/game/variables.hpp	2009-10-26 19:04:31.000000000 +0100
+++ teeworlds-0.5.2-teecomp/src/game/variables.hpp	2009-10-27 19:06:18.000000000 +0100
@@ -44,6 +44,9 @@
 
 MACRO_CONFIG_INT(gfx_noclip, 0, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Disable clipping")
 
+/* TeeComp */
+#include "teecomp_vars.hpp"
+
 /* server */
 MACRO_CONFIG_INT(sv_warmup, 0, 0, 0, CFGFLAG_SERVER, "Number of seconds to do warpup before round starts")
 MACRO_CONFIG_STR(sv_motd, 900, "", CFGFLAG_SERVER, "Message of the day to display for the clients")
diff -Nru teeworlds-0.5.2-src/src/game/version.hpp teeworlds-0.5.2-teecomp/src/game/version.hpp
--- teeworlds-0.5.2-src/src/game/version.hpp	2009-10-26 19:04:31.000000000 +0100
+++ teeworlds-0.5.2-teecomp/src/game/version.hpp	2009-11-10 17:14:50.000000000 +0100
@@ -2,3 +2,4 @@
 #include "generated/nethash.c"
 #define GAME_VERSION "0.5.2"
 #define GAME_NETVERSION "0.5 " GAME_NETVERSION_HASH
+#define TEECOMP_VERSION "0.7.0"
